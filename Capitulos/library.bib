Automatically generated by Mendeley Desktop 1.17.10
Any changes to this file will be lost if it is regenerated by Mendeley.

BibTeX export options can be customized via Preferences -> BibTeX in Mendeley Desktop

@article{Telea2008,
abstract = {Understanding detailed changes done to source code is of great importance in software maintenance. We present Code Flows, a method to visualize the evolution of source code geared to the understanding of fine and mid-level scale changes across several file versions. We enhance an existing visual metaphor to depict software structure changes with techniques that emphasize both following unchanged code as well as detecting and highlighting important events such as code drift, splits, merges, insertions and deletions. The method is illustrated with the analysis of a real-world C++ code system.},
author = {Telea, Alexandru and Auber, David},
doi = {10.1111/j.1467-8659.2008.01214.x},
file = {:Users/leosilva/Documents/Estudo/Mestrado/Dissertacao/Referencias/Telea{\_}et{\_}al-2008-Computer{\_}Graphics{\_}Forum.pdf:pdf},
isbn = {0167-7055},
issn = {01677055},
journal = {Computer Graphics Forum},
number = {3},
pages = {831--838},
title = {{Code flows: Visualizing structural evolution of source code}},
volume = {27},
year = {2008}
}
@article{Feist2016,
author = {Feist, Michael D and Santos, Eddie Antonio and Watts, Ian and Hindle, Abram},
doi = {10.1109/VISSOFT.2016.6},
file = {:Users/leosilva/Documents/Estudo/Mestrado/Dissertacao/Referencias/07780152.pdf:pdf},
isbn = {9781509038503},
journal = {2016 IEEE 4rd Working Conference on Software Visualization, VISSOFT 2016 - Proceeding},
title = {{Visualizing Project Evolution Through Abstract Syntax Tree Analysis}},
year = {2016}
}
@misc{Dynatrace2016,
author = {Dynatrace},
booktitle = {2016},
title = {{Dynatrace}},
url = {http://www.dynatrace.com/},
year = {2016}
}
@incollection{LehmanMeirMandRamilJuanFandWernickPaulDandPerryDewayneEandTurski,
author = {{Lehman, Ramil, Wernick, Perry}, Turski},
booktitle = {IEEE, Piscataway},
file = {:Users/leosilva/Documents/Estudo/Mestrado/Dissertacao/Referencias/1997{\_}Lehman{\_}Nineties.pdf:pdf},
pages = {20--32},
publisher = {IEEE},
title = {{Metrics and laws of software evolution—the nineties view}},
year = {1997}
}
@article{Dmitriev2004,
abstract = {Instrumentation-based profiling has many advantages and one serious disadvantage: usually high performance overhead. This overhead can be substantially reduced if only a small part of the target application (for example, one that has previously been identified as a performance bottleneck) is instrumented, while the rest of the application code continues to run at full speed. The value of such a profiling technology would increase further if the code could be instrumented and de-instrumented as many times as needed at run time.In this paper we present an experimental profiling system called JFluid, which includes a modified Java™ VM and a GUI tool, and addresses both of the above issues. Our tool supports instrumentation of a group of methods defined as an arbitrary "root" method plus all methods that it calls (a call subgraph). It appears that static determination of all methods in a call subgraph is difficult in presence of virtual methods, bug fortunately, with dynamic code hotswapping available, two schemes of dynamic call subgraph revelation and instrumentation can be suggested. Measurements that we obtained when performing full and partial program profiling using both schemes show that the overhead can be reduced substantially using this technique, and that one of the schemes generally results in a smaller number of instrumented methods and better performance. Furthermore, we observe that our approach generally works much better for large (for example, J2EE and Web) applications, than for small benchmarks.},
author = {Dmitriev, Mikhail},
doi = {10.1145/974043.974067},
file = {:Users/leosilva/Documents/Estudo/Mestrado/Dissertacao/Referencias/p139-dmitriev.pdf:pdf},
isbn = {1581136730},
issn = {01635948},
journal = {ACM SIGSOFT Software Engineering Notes},
number = {1},
pages = {139},
title = {{Profiling Java applications using code hotswapping and dynamic call graph revelation}},
volume = {29},
year = {2004}
}
@article{Holten2008,
abstract = {We provide a novel visualization method for the comparison of hierarchically organized data. Our technique visualizes a pair of hierarchies that are to be compared and simultaneously depicts how these hierarchies are related by explicitly visualizing the relations between matching subhierarchies. Elements that are unique to each hierarchy are shown, as well as the way in which hierarchy elements are relocated, split or joined. The relations between hierarchy elements are visualized using Hierarchical Edge Bundles (HEBs). HEBs reduce visual clutter, they visually emphasize the aforementioned splits, joins, and relocations of subhierarchies, and they provide an intuitive way in which users can interact with the relations. The focus throughout this paper is on the comparison of different versions of hierarchically organized software systems, but the technique is applicable to other kinds of hierarchical data as well. Various data sets of actual software systems are used to show how our technique can be employed to easily spot splits, joins, and relocations of elements, how sorting both hierarchies with respect to each other facilitates comparison tasks, and how user interaction is supported. {\textcopyright} 2008 The Eurographics Association and Blackwell Publishing Ltd.},
author = {Holten, Danny and {Van Wijk}, Jarke J.},
doi = {10.1111/j.1467-8659.2008.01205.x},
isbn = {1467-8659},
issn = {01677055},
journal = {Computer Graphics Forum},
number = {3},
pages = {759--766},
title = {{Visual comparison of hierarchically organized data}},
volume = {27},
year = {2008}
}
@misc{Vis,
author = {VisualVM},
title = {{VisualVM}},
url = {https://visualvm.github.io},
year = {2016}
}
@article{Sousa2009,
author = {Sousa, FRC and Moreira, LO and Machado, JC},
file = {:Users/leosilva/Documents/Estudo/Mestrado/Dissertacao/Referencias/Computacao{\_}em{\_}Nuvem{\_}Conceitos{\_}Tecnologias{\_}Aplicaco.pdf:pdf},
journal = {Cear{\'{a}}: Universidade Federal do {\ldots}},
number = {September},
title = {{Computa{\c{c}}{\~{a}}o em nuvem: Conceitos, tecnologias, aplica{\c{c}}{\~{o}}es e desafios}},
url = {http://www.lia.ufc.br/{~}flavio/papers/ercemapi2009.pdf},
year = {2009}
}
@unpublished{JProfiler,
author = {JProfiler},
title = {{JProfiler}},
url = {https://www.ej-technologies.com/products/jprofiler/overview.html},
year = {2016}
}
@misc{Netty2016,
author = {Netty},
title = {{Netty}},
url = {http://netty.io},
year = {2016}
}
@misc{JointJS2017,
author = {JointJS},
title = {{JointJS}},
url = {http://jointjs.com},
year = {2017}
}
@misc{ApacheJMeter2016,
abstract = {The Apache JMeter™ desktop application is open source software, a 100{\%} pure Java application designed to load test functional behavior and measure performance. It was originally designed for testing Web Applications but has since expanded to other test functions.},
author = {{Apache JMeter}},
booktitle = {2016},
isbn = {9781847192950},
pages = {1},
title = {{Apache JMeter}},
url = {http://jmeter.apache.org/},
year = {2016}
}
@article{Paredes2014,
abstract = {Understanding information about software artifacts is key to successful$\backslash$nAgile software development projects; however, sharing information about$\backslash$nartifacts is difficult to achieve amongst team members. There are many$\backslash$ninformation visualization techniques used to help address the$\backslash$ndifficulties of knowledge sharing, but it is not clear what is the most$\backslash$neffective technique. This paper presents the results of a systematic$\backslash$nmapping study of existing literature on information visualization$\backslash$ntechniques used by Agile software development teams. The results of the$\backslash$nsystematic mapping show that Agile teams use visualization techniques$\backslash$nfor designing, developing, communicating, and tracking progress. Our$\backslash$nfindings show that visualization techniques help Agile teams increase$\backslash$nknowledge sharing and raise awareness about software artifacts amongst$\backslash$nteam members.},
author = {Paredes, Julia and Anslow, Craig and Maurer, Frank},
doi = {10.1109/VISSOFT.2014.32},
file = {:Users/leosilva/Documents/Estudo/Mestrado/Dissertacao/Referencias/JuliaParedes{\_}Paper8{\_}VISSOFT.pdf:pdf},
isbn = {978-0-7695-5305-4},
journal = {2014 Second Ieee Working Conference on Software Visualization (Vissoft)},
keywords = {agile software development,agile teams have used,big visible charts,different visual-,for this reason,information radiator,information visualiza-,knowledge sharing,software visualization,systematic mapping,tion},
pages = {157--166},
title = {{Information Visualization for Agile Software Development Teams}},
year = {2014}
}
@article{Treude2015,
abstract = {Software developers pursue a wide range of activities as part of their work, and making sense of what they did in a given time frame is far from trivial as evidenced by the large number of awareness and coordination tools that have been developed in recent years. To inform tool design for making sense of the information available about a developer's activity, we conducted an empirical study with 156 GitHub users to investigate what information they would expect in a summary of development activity, how they would measure development activity, and what factors influence how such activity can be condensed into textual summaries or numbers. We found that unexpected events are as important as expected events in summaries of what a developer did, and that many developers do not believe in measuring development activity. Among the factors that influence summarization and measurement of development activity, we identified development experience and programming languages. {\textcopyright} 2015 ACM.},
author = {Treude, Christoph and {Figueira Filho}, Fernando and Kulesza, Uir{\'{a}}},
doi = {10.1145/2786805.2786827},
file = {:Users/leosilva/Documents/Estudo/Mestrado/Dissertacao/Referencias/p625-treude.pdf:pdf},
isbn = {9781450336758},
journal = {Proceedings of the 2015 10th Joint Meeting on Foundations of Software Engineering},
keywords = {development activity,empirical study,summarization},
pages = {625--636},
title = {{Summarizing and measuring development activity}},
year = {2015}
}
@article{Abreu1995,
author = {Abreu, Fb and Goul{\~{a}}o, Miguel},
file = {:Users/leosilva/Documents/Estudo/Mestrado/Dissertacao/Referencias/1995{\_}5ICSQ.pdf:pdf},
journal = {Proc. 5th Int'l Conf. Software Quality},
number = {October},
pages = {44--57},
title = {{Toward the design quality evaluation of object-oriented software systems}},
url = {http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.14.6468{\&}rep=rep1{\&}type=pdf},
year = {1995}
}
@article{Bateman2009,
abstract = {Usage data logged from user interactions can be extremely valuable for evaluating software usability. However, instrumenting software to collect usage data is a time-intensive task that often requires technical expertise as well as an understanding of the usability issues to be explored. We have developed a new technique for software instrumentation that removes the need for programming. Interactive Usability Instrumentation (IUI) allows usability evaluators to work directly with a system's interface to specify what components and what events should be logged. Evaluators are able to create higher-level abstractions on the events they log and are provided with real-time feedback on how events are logged. As a proof of the IUI concept, we have created the UMARA system, an instrumentation system that is enabled by recent advances in aspect-oriented programming. UMARA allows users to instrument software without the need for additional coding, and provides tools for specification, data collection, and data analysis. We report on the use of UMARA in the instrumentation of two large open-source projects; our experiences show that IUI can substantially simplify the process of log-based usability evaluation},
author = {Bateman, Scott and Gutwin, Carl and Osgood, Nathaniel and McCalla, Gordon},
doi = {10.1145/1570433.1570443},
file = {:Users/leosilva/Documents/Estudo/Mestrado/Dissertacao/Referencias/p45-bateman.pdf:pdf},
isbn = {9781605586007},
journal = {Proceedings of the 1st ACM SIGCHI symposium on Engineering interactive computing systems},
keywords = {aspect-oriented programming,instrumentation,software logging,usability},
pages = {45--54},
title = {{Interactive usability instrumentation}},
url = {http://doi.acm.org/10.1145/1570433.1570443},
year = {2009}
}
@article{DAmbros2009,
abstract = {The analysis of the evolution of large software systems is challenging for many reasons, such as the retrieval and processing of historical information and the large quantity of data that must be dealt with. While recent advances in research have led to the solutions to these problems, a central question remains: How do we deal with this information in a methodical way and where do we start with our analysis? We present a methodology based on interactive visualizations that support the reconstruction of the evolution of software systems. We propose several visualizations which help us to perform software evolution analysis of a system ‘in the large' and ‘in the small', and apply them to two large systems. The analysis of the evolution of large software systems is challenging for many reasons, such as the retrieval and processing of historical information and the large quantity of data that must be dealt with. We present a methodology based on interactive visualizations which support the reconstruction of the evolution of software systems. We propose several visualizations which help us to perform software evolution analysis of a system ‘in the large' and ‘in the small', and apply them to two large systems.},
author = {D'Ambros, Marco and Lanza, Michele},
doi = {10.1002/smr.407},
file = {:Users/leosilva/Documents/Estudo/Mestrado/Dissertacao/Referencias/Research{\_}Visual{\_}Software{\_}Evolution{\_}Reconstruction.pdf:pdf},
issn = {1532060X},
journal = {Journal of Software Maintenance and Evolution},
keywords = {Software evolution analysis,Software visualization},
number = {3},
pages = {217--232},
title = {{Visual software evolution reconstruction}},
volume = {21},
year = {2009}
}
@book{Taylor2009,
author = {Taylor, Richard N and Medvidovic, Nenad and Dashofy, Eric M},
doi = {10.1145/1810295.1810435},
isbn = {978-1-60558-719-6},
issn = {0270-5257},
publisher = {Wiley Publishing},
title = {{Software architecture: foundations, theory, and practice}},
year = {2009}
}
@article{Meyer2006,
abstract = {Data visualization is the process of representing data as pictures to support reasoning about the underlying data. For the interpretation to be as easy as possible, we need to be as close as possible to the original data. As most visualization tools have an internal meta-model, which is different from the one for the presented data, they usually need to duplicate the original data to conform to their meta-model. This leads to an increase in the resources needed, increase which is not always justified. In this work we argue for the need of having an engine that is as close as possible to the data and we present our solution of moving the visualization tool to the data, instead of moving the data to the visualization tool. Our solution also emphasizes the necessity of reusing basic blocks to express complex visualizations and allowing the programmer to script the visualization using his preferred tools, rather than a third party format. As a validation of the expressiveness of our framework, we show how we express several already published visualizations and describe the pros and cons of the approach.},
author = {Meyer, Michael and G{\^{i}}rba, Tudor and Lungu, Mircea},
doi = {10.1145/1148493.1148513},
file = {:Users/leosilva/Downloads/Meye06aMondrian.pdf:pdf},
isbn = {1595934642},
journal = {Proceedings of the 2006 ACM symposium on Software visualization  - SoftVis '06},
keywords = {graph visualization,model,software visualization},
number = {SoftVis},
pages = {135},
title = {{Mondrian}},
url = {http://portal.acm.org/citation.cfm?doid=1148493.1148513},
year = {2006}
}
@article{Pinzger2005,
abstract = {Observing the evolution of very large software systems needs the analysis of large complex data models and visualization of condensed views on the system. For visualization software metrics have been used to compute such condensed views. However, current techniques concentrate on visualizing data of one particular release providing only insufficient support for visualizing data of several releases.In this paper we present the RelVis visualization approach that concentrates on providing integrated condensed graphical views on source code and release history data of up to n releases. Measures of metrics of source code entities and relationships are composed in Kiviat diagrams as annual rings. Diagrams highlight the good and bad times of an entity and facilitate the identification of entities and relationships with critical trends. They represent potential refactoring candidates that should be addressed first before further evolving the system. The paper provides needed background information and evaluation of the approach with a large open source software project.},
author = {Pinzger, Martin and Gall, Harald and Fischer, Michael and Lanza, Michele},
doi = {10.1145/1056018.1056027},
file = {:Users/leosilva/Documents/Estudo/Mestrado/Dissertacao/Referencias/visualizing{\_}multiple{\_}evolution{\_}metrics.pdf:pdf},
isbn = {1595930736},
journal = {Proceedings of the 2nd ACM symposium on Software visuallization},
keywords = {Kiviat,evolution metrics,software evolution analysis,software visualization},
number = {212},
pages = {67},
title = {{Visualizing multiple evolution metrics}},
url = {http://dl.acm.org/citation.cfm?id=1056018.1056027},
volume = {1},
year = {2005}
}
@article{Liu2014,
abstract = {Information visualization (InfoVis), the study of transforming data, information, and knowledge into interactive visual representations, is very important to users because it provides mental models of information. The boom in big data analytics has triggered broad use of InfoVis in a variety of domains, ranging from finance to sports to politics. In this paper, we present a comprehensive survey and key insights into this fast-rising area. The research on InfoVis is organized into a taxonomy that contains four main categories, namely empirical methodologies, user interactions, visualization frameworks, and applications, which are each described in terms of their major goals, fundamental principles, recent trends, and state-of-the-art approaches. At the conclusion of this survey, we identify existing technical challenges and propose directions for future research.},
author = {Liu, Shixia and Cui, Weiwei and Wu, Yingcai and Liu, Mengchen},
doi = {10.1007/s00371-013-0892-3},
file = {:Users/leosilva/Documents/Estudo/Mestrado/Dissertacao/Referencias/paper.pdf:pdf},
isbn = {0178-2789},
issn = {01782789},
journal = {Visual Computer},
keywords = {Information visualization,Interactive techniques,Large datasets},
number = {12},
pages = {1373--1393},
title = {{A survey on information visualization: recent advances and challenges}},
volume = {30},
year = {2014}
}
@article{McNair2007,
abstract = {When trying to understand the evolution of a software system it can be useful to visualize the evolution of the system's architecture. Existing tools for viewing architectural evolution assume that what a user is interested in can be described in an unbroken sequence of time, for example the changes over the last six months. We present an alternative approach that provides a lightweight method for examining the net effect of any set of changes on a system's architecture. We also present Motive, a prototype tool that implements this approach, and demonstrate how it can be used to answer questions about software evolution by describing case studies we conducted on two Java systems.},
author = {McNair, a. and German, D.M. and Weber-Jahnke, J.},
doi = {10.1109/WCRE.2007.52},
file = {:Users/leosilva/Documents/Estudo/Mestrado/Dissertacao/Referencias/dmg2007{\_}wcre{\_}changesets.pdf:pdf},
isbn = {978-0-7695-3034-5},
issn = {1095-1350},
journal = {14th Working Conference on Reverse Engineering (WCRE 2007)},
title = {{Visualizing Software Architecture Evolution Using Change-Sets}},
year = {2007}
}
@article{Zimmer2010,
abstract = {Dynamic recompilation tries to produce more efficient code by exploiting runtime information. Virtual machines like the Jikes RVM use recompilation heuristics to decide how to recompile the program, i.e. what parts are recompiled at what level of optimization. In this paper we present our post-mortem amortization analysis based on improved call stack sampling. Our tool presents the results of the analysis as an interactive visualizations to help both virtual machine implementors improve their recompilation strategies, as well as programmers assess whether these recompilation strategies pay off not only for their application as a whole, but also for individual methods.},
author = {Zimmer, Stephan and Diehl, Stephan},
doi = {10.1109/IV.2010.76},
isbn = {9780769541655},
issn = {10939547},
journal = {Proceedings of the International Conference on Information Visualisation},
keywords = {Dynamic analysis,Recompilation,Software visualization},
pages = {509--514},
title = {{Visual amortization analysis of recompilation strategies}},
year = {2010}
}
@inproceedings{Steinbruckner2010,
annote = {NULL},
author = {Steinbr{\"{u}}ckner, Frank},
booktitle = {IEEE International Conference on Software Maintenance, ICSM},
doi = {10.1109/ICSM.2010.5610421},
file = {:Users/leosilva/Documents/Estudo/Mestrado/Dissertacao/Referencias/Dissertation{\_}Steinbrueckner{\_}F.pdf:pdf},
isbn = {9781424486298},
keywords = {Software cities,Software evolution,Software visualization},
month = {sep},
number = {November},
pages = {1--2},
publisher = {IEEE},
title = {{Coherent software cities: Supporting comprehension of evolving software systems}},
url = {http://ieeexplore.ieee.org/document/5610421/},
year = {2010}
}
@article{Gomez-Henriquez2001a,
abstract = {This article provides a general overview of software visualization. To that end, we first present the concept of visualization and its features, and later we summarize some of its main applications in Computer Science. The main part of this article is devoted to describing the general discipline of software visualization, by defining it and its main problems and uses. Throughout the paper we will refer to some of the most outstanding actual systems which we think are suitable to illustrate the corresponding concept},
author = {Gomez-Henriquez, Luis M.},
file = {:Users/leosilva/Documents/Estudo/Mestrado/Dissertacao/Referencias/10.1.1.23.8935.pdf:pdf},
journal = {Informatik},
keywords = {debugging,performance debugging,program,software visualization,visualization},
number = {2},
pages = {4--7},
title = {{Software Visualization: An Overview}},
url = {http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.23.8935{\&}rep=rep1{\&}type=pdf},
volume = {2},
year = {2001}
}
@article{Wettel2007,
abstract = {This paper presents a 3D visualization approach which gravitates around the city metaphor, i.e., an object-oriented software system is represented as a city that can be traversed and interacted with: the goal is to give the viewer a sense of locality to ease program comprehension. The key point in conceiving a realistic software city is to map the information about the source code in meaningful ways in order to take the approach beyond beautiful pictures. We investigated several concepts that contribute to the urban feeling, such as appropriate layouts, topology, and facilities to ease navigation and interaction. We experimented our approach on a number of systems, and present our findings.},
author = {Wettel, Richard and Lanza, Michele},
doi = {10.1109/VISSOF.2007.4290706},
file = {:Users/leosilva/Documents/Estudo/Mestrado/Dissertacao/Referencias/visualizing{\_}software{\_}systems{\_} as{\_}cities.pdf:pdf},
isbn = {1424406005},
journal = {VISSOFT 2007 - Proceedings of the 4th IEEE International Workshop on Visualizing Software for Understanding and Analysis},
pages = {92--99},
title = {{Visualizing software systems as cities}},
year = {2007}
}
@misc{Profiler2016,
author = {Profiler, YourKit Java},
title = {{YourKit Java Profiler}},
url = {https://www.yourkit.com/java/profiler/features/},
year = {2016}
}
@misc{VRaptor2017,
author = {VRaptor},
title = {{VRaptor}},
url = {http://www.vraptor.org},
year = {2017}
}
@Patent{burckhardt1989anti,
author = {Burckhardt, Manfred and Brugger, Franz and Faulhaber, Andreas},
file = {:Users/leosilva/Documents/Estudo/Mestrado/Dissertacao/Referencias/US4861118.pdf:pdf},
publisher = {US Patent 4,861,118},
title = {{Anti-lock brake system}},
year = {1989}
}
@article{Sensalire2009,
abstract = {Many software visualization (SoftVis) tools are continuously being developed by both researchers as well as software development companies. In order to determine if the developed tools are effective in helping their target users, it is desirable that they are exposed to a proper evaluation. Despite this, there is still lack of a general guideline on how these evaluations should be carried out and many of the tool developers perform very limited or no evaluation of their tools. Each person that carries out one evaluation, however, has experiences which, if shared, can guide future evaluators. This paper presents the lessons learned from evaluating over 20 SoftVis tools with over 90 users in five different studies spread on a period of over two years. The lessons covered include the selection of the tools, tasks, as well as evaluation participants. Other discussed points are related to the duration of the evaluation experiment, its location, the procedure followed when carrying out the experiment, as well as motivation of the participants. Finally, an analysis of the lessons learned is shown with the hope that these lessons will be of some assistance to future SoftVis tool evaluators.},
author = {Sensalire, Mariam and Ogao, Patrick and Telea, Alexandru},
doi = {10.1109/VISSOF.2009.5336431},
file = {:Users/leosilva/Documents/Estudo/Mestrado/Dissertacao/Referencias/2009ProcVisSoftSensalire.pdf:pdf},
isbn = {978-1-4244-5027-5},
journal = {2009 5th IEEE International Workshop on Visualizing Software for Understanding and Analysis},
keywords = {Animation,Cinematography,Computer graphics,DP industry,Design engineering,Guidelines,Mathematics,Performance evaluation,Programming,SoftVis tools,Software tools,Visualization,data visualisation,software development companies,software performance evaluation,software visualization tools},
pages = {19--26},
pmid = {5336431},
title = {{Evaluation of software visualization tools: Lessons learned}},
url = {http://ieeexplore.ieee.org/lpdocs/epic03/wrapper.htm?arnumber=5336431},
year = {2009}
}
@article{BeladyLaszloA.andLehman1976,
abstract = {Currently, the process of large-scale program development and maintenance appears to be unpredictable; its costs are high and its output is a fragile product. Clearly, one should try to reach beyond understanding and attempt to change the process for the better.},
author = {Belady, L. A. and Lehman, M. M.},
doi = {10.1147/sj.153.0225},
isbn = {0018-8670},
issn = {0018-8670},
journal = {IBM Systems Journal},
number = {3},
pages = {225--252},
title = {{A model of large program development}},
volume = {15},
year = {1976}
}
@article{Gallagher2005,
author = {Gallagher, Keith and Hatch, Andrew and Munro, Malcolm},
doi = {10.1109/VISSOF.2005.1684309},
title = {{A framework for software architecture visualization assessment}},
url = {http://ieeexplore.ieee.org/document/1684309/},
year = {2005}
}
@book{Diehl2007,
abstract = {In this book we give an overview of the various areas of software visu- alization, the art and science of generating visual representations of various aspects of software and its development process. In contrast to visual programming and diagramming for software design, software visualization is not so much concerned with the construction, but with the analysis of programs and their development process. So far, there exist only anthologies and proceedings about software visu- alization. This book is the first textbook on software visualization. Although written mostly for graduate students, the book is also a valuable resource for researchers as it provides a broad and systematic overview of the area with many pointers to literature and systems for further study},
author = {Diehl, Stephan},
booktitle = {Software Visualization: Visualizing the Structure, Behaviour, and Evolution of Software},
doi = {10.1007/978-3-540-46505-8},
file = {:Users/leosilva/Documents/Estudo/Mestrado/Dissertacao/Referencias/Software Visualization - Stasko, John (edt).pdf:pdf},
isbn = {9783540465041},
issn = {0018-9162},
pages = {1--187},
pmid = {14736262},
title = {{Software visualization: Visualizing the structure, behaviour, and evolution of software}},
year = {2007}
}
@inproceedings{Bezemer2015,
abstract = {Flame graphs are gaining rapidly in popularity in industry to visualize performance profiles collected by stack-trace based profilers. In some cases, for example, during performance regression detection, profiles of different software versions have to be compared. Doing this manually using two or more flame graphs or textual profiles is tedious and error-prone. In this `Early Research Achievements'-track paper, we present our preliminary results on using differential flame graphs instead. Differential flame graphs visualize the differences between two performance profiles. In addition, we discuss which research fields we expect to benefit from using differential flame graphs. We have implemented our approach in an open source prototype called FLAMEGRAPHDIFF, which is available on GitHub. FLAMEGRAPHDIFF makes it easy to generate interactive differential flame graphs from two existing performance profiles. These graphs facilitate easy tracing of elements in the different graphs to ease the understanding of the (d)evolution of the performance of an application.$\backslash$r$\backslash$n},
author = {Bezemer, Cor Paul and Pouwelse, Johan and Gregg, Brendan},
booktitle = {2015 IEEE 22nd International Conference on Software Analysis, Evolution, and Reengineering, SANER 2015 - Proceedings},
doi = {10.1109/SANER.2015.7081872},
file = {:Users/leosilva/Documents/Estudo/Mestrado/Dissertacao/Referencias/dfgs.pdf:pdf},
isbn = {9781479984695},
number = {April},
pages = {535--539},
title = {{Understanding software performance regressions using differential flame graphs}},
year = {2015}
}
@phdthesis{Pinto2015,
abstract = {The maintenance and evolution of software systems have become a critical task over the last years due to the diversity and high demand of features, devices and users. The ability to understand and analyze how newly introduced changes impact the quality attributes of the architecture of those software systems is an essential prerequisite for avoiding the deterioration of the engineering quality of them during their evolution. This thesis proposes an automated approach for the deviation analysis of the quality attribute of performance in terms of execution time (response time). It is implemented by a framework that adopts dynamic analysis and mining software repository techniques to provide an automated way to revel potential sources – commits and issues – of performance deviation in scenarios of an evolving software system. The approach defines four phases: (i) preparation – choosing the scenarios and preparing the target releases; (ii) dynamic analysis – determining the performance of scenarios and methods by calculating their execution time; (iii) deviation analysis – processing and comparing the results of the dynamic analysis for different releases; and (iv) repository mining – identifying development issues and commits associated with performance deviation. Empirical studies have been developed to assess the approach from different perspectives. An exploratory study analyzed the feasibility of applying the approach in systems from different domains to automatically identifying source code assets with performance deviation and the changes that have affected them during an evolution. This study was performed using three systems: (i) SIGAA – a web academic management system; (ii) ArgoUML – an UML modeling tool; and (iii) Netty – a network application framework. Another study has performed an evolutionary analysis of applying the approach to multiple releases of Netty, and the web frameworks Wicket and Jetty. It has analyzed twenty-one releases (seven releases of each system) and addressed a total of 57 scenarios. Overall, we have found 14 scenarios with significant performance deviation for Netty, 13 for Wicket, and 9 for Jetty. In addition, the feedback obtained from an online survey with eight developers of Netty, Wicket and Jetty is also discussed. Finally, in our last study, we built a performance regression model in order to indicate the properties of code changes that are more likely to cause performance degradation. We mined a total of 997 commits, of which 103 were retrieved from degraded code assets, 19 from optimized, while 875 had no impact on execution time. Number of days before release and day of week were the most relevant variables of commits that cause performance degradation in our model. The receiver operating characteristic (ROC) area of our regression model is 60{\%}, which means that deciding if a commit will cause performance degradation or not by using the model is 10{\%} better than a random guess.},
author = {Pinto, Felipe Alves Pereira.},
file = {:Users/leosilva/Documents/Estudo/Mestrado/Dissertacao/Referencias/felipe-tese-doutorado-final-com-ficha.pdf:pdf},
keywords = {dynamic analysis,performance deviation analysis,quality attributes,regression model,software evolution,software repository mining},
pages = {154},
school = {UFRN - Universidade Federal do Rio Grande do Norte},
title = {{An Automated Approach for Performance Deviation Analysis of Evolving Software Systems}},
volume = {1},
year = {2015}
}
@article{Corbi1989,
abstract = {In the Program Understanding Project at IBM's Research Division, work began in late 1986 on tools which could help programmers in two key areas: static analysis (reading the code) and dynamic analysis (running the code). The work is reported in the companion papers by Cleveland and by Pazel in this issue. The history and background which motivated and which led to the start of this research on tools to assist programmers in understanding existing program code is reported here.},
author = {Corbi, T. A.},
doi = {10.1147/sj.282.0294},
isbn = {0018-8670},
issn = {0018-8670},
journal = {IBM Systems Journal},
number = {2},
pages = {294--306},
title = {{Program understanding: Challenge for the 1990s}},
volume = {28},
year = {1989}
}
@article{Balzer2007,
abstract = {The level-of-detail techniques presented in this paper enable a comprehensible interactive visualization of large and complex clustered graph layouts either in 2D or 3D. Implicit surfaces are used for the visually simplified representation of vertex clusters, and so-called edge bundles are formed for the simplification of edges. Additionally, dedicated transition techniques are provided for continuously adaptive and adjustable views of graphs that range from very abstract to very detailed representations},
author = {Balzer, Michael and Deussen, Oliver},
doi = {10.1109/APVIS.2007.329288},
file = {:Users/leosilva/Documents/Estudo/Mestrado/Dissertacao/Referencias/BaDe07.pdf:pdf},
isbn = {1424408083},
journal = {Asia-Pacific Symposium on Visualisation 2007, APVIS 2007, Proceedings},
keywords = {Clustered graphs,Edge bundles,Graph visualization,Implicit surfaces,Level-of-detail},
pages = {133--140},
title = {{Level-of-detail visualization of clustered graph layouts}},
year = {2007}
}
@article{Williamson1989,
abstract = {This paper describes the development of the Traffic Alert and Collision Avoidance System (TCAS), provides a description of the TCAS II system operation, offers results of operational evaluations conducted in cooperation with Piedmont, United, and Northwest Airlines, and finally provides the status and progress of the TCAS implementation. TCAS is the culmination of more than 30 years of work by the aviation community to develop a viable collision avoidance system to complement the Federal Aviation Administration's ground-based air traffic control (ATC) system. In recent years this effort has focused on concepts that make use of the radar transponders carried by aircraft for ground ATCpurposes. A transponder-based collision avoidance system has the advantage that it can provide immediate protection against the vast population of aircraft already equipped with either the current Air Traffic Control Radar Beacon System (ATCRBS) transponder or the new Mode S transponder. The TCAS concept encompasses a range of capabilities including TCAS I, which provides traffic advisories (bearing, range, and relative altitude) to assist the pilot in visually acquiring the threat aircraft, TCAS II, which provides traffic and resolution advisories (recommended escape maneuvers) in the vertical plane, and TCAS II, which provides traffic and resolution advisories in both the vertical and horizontal planes.},
author = {Williamson, Thomas and Spencer, Ned A.},
doi = {10.1109/5.47735},
file = {:Users/leosilva/Documents/Estudo/Mestrado/Dissertacao/Referencias/00047735.pdf:pdf},
isbn = {0018-9219},
issn = {15582256},
journal = {Proceedings of the IEEE},
number = {11},
pages = {1735--1744},
title = {{Development and Operation of the Traffic Alert and Collision Avoidance System (TCAS)}},
volume = {77},
year = {1989}
}
@article{Gall2006,
abstract = {Gaining higher level evolutionary information about large software systems is a key challenge in dealing with increasing complexity and decreasing software quality. Software repositories such as modifications, changes, or release information are rich sources for distinctive kinds of analyses: They reflect the reasons and effects of particular changes made to the software system over a certain period of time. If we can analyze these repositories in an effective way, we get a clearer picture of the status of the software. Software repositories can be analyzed to provide information about the problems concerning a particular feature or a set of features. Hidden dependencies of structurally unrelated but over time logically coupled files exhibit a high potential to illustrate software evolution and possible architectural deterioration. In this tutorial, we describe the investigation of software evolution by taking a step towards reflecting the analysis results against software quality attributes. Different kinds of analyses (from architecture to code) and their interpretation will be presented and discussed in relation to quality attributes. This will show our vision of where such evolution investigations can lead and how they can support development. For that, the tutorial will touch issues such as meta-models for evolution data, data analysis and history mining, software quality attributes, as well as visualization of analysis results.},
author = {Gall, Harald C and Lanza, Michele},
doi = {10.1145/1134285.1134502},
file = {:Users/leosilva/Documents/Estudo/Mestrado/Dissertacao/Referencias/283201055.pdf:pdf},
isbn = {1595933751},
journal = {Conference On Software Maintenance},
keywords = {2,be adapted,can existing analysis methods,com-,evolution be discovered,how,how can hidden dependencies,in a system that,or,plicate and hinder its,revised,software evolution,visualization},
pages = {1055--1056},
title = {{Software Evolution : Analysis and Visualization}},
url = {http://www.cs.uvic.ca/{~}chisel/thesis/David{\_}Perrin{\_}Thesis.pdf},
volume = {2006},
year = {2006}
}
@misc{Jetty2016,
author = {Jetty},
title = {{Jetty}},
url = {http://www.eclipse.org/jetty/},
year = {2016}
}
@article{Pinzger2008,
abstract = {Many program comprehension tools use graphs to visualize and analyze source code. The main issue is that existing approaches create graphs overloaded with too much information. Graphs contain hundreds of nodes and even more edges that cross each other. Understanding these graphs and using them for a given program comprehension task is tedious, and in the worst case developers stop using the tools. In this paper we present DA4Java, a graph-based approach for visualizing and analyzing static dependencies between Java source code entities. The main contribution of DA4Java is a set of features to incrementally compose graphs and remove irrelevant nodes and edges from graphs. This leads to graphs that contain significantly fewer nodes and edges and need less effort to understand.},
author = {Pinzger, Martin and Gr{\"{a}}fenhain, Katja and Knab, Patrick and Gall, Harald C.},
doi = {10.1109/ICPC.2008.23},
file = {:Users/leosilva/Documents/Estudo/Mestrado/Dissertacao/Referencias/629a0fd5ea62d415e807ad5562c382aa2db9.pdf:pdf},
isbn = {9780769531762},
issn = {1063-6897},
journal = {IEEE International Conference on Program Comprehension},
pages = {254--259},
title = {{A tool for visual understanding of source code dependencies}},
year = {2008}
}
@article{Collberg2003,
abstract = {We describe GEVOL, a system that visualizes the evolution of software using a novel graph drawing technique for visualization of large graphs with a temporal component. GEVOL extracts information about a Java program stored within a CVS version control system and displays it using a temporal graph visualizer. This information can be used by programmers to understand the evolution of a legacy program: Why is the program structured the way it is? Which programmers were responsible for which parts of the program during which time periods? Which parts of the program appear unstable over long periods of time and may need to be rewritten? This type of information will complement that produced by more static tools such as source code browsers, slicers, and static analyzers.},
author = {Collberg, Christian and Kobourov, Stephen and Nagra, Jasvir and Pitts, Jacob and Wampler, Kevin},
doi = {10.1145/774833.774844},
file = {:Users/leosilva/Documents/Estudo/Mestrado/Dissertacao/Referencias/p77-collberg.pdf:pdf},
isbn = {1581136420},
journal = {Proceedings of the 2003 ACM symposium on Software visualization - SoftVis '03},
pages = {77},
title = {{A system for graph-based visualization of the evolution of software}},
url = {http://portal.acm.org/citation.cfm?doid=774833.774844},
year = {2003}
}
@article{Lanza2002,
abstract = {Coping with huge amounts of data is one of the major problems in the context of software evolution. Current approaches reduce this complexity by filtering out irrelevant information. In this paper we propose an approach based on a combination of software visualization and software metrics, as software visualization is apt for complexity reduction and metrics introduce the possibility to qualify evolution. We discuss a simple and effective way to visualize the evolution of software systems which helps to recover the evolution of object oriented software systems. In addition we define a vocabulary that qualifies some specific situations that occurs when considering system evolution.},
author = {Lanza, Michelle and Ducasse, St{\'{e}}phane},
doi = {10.3166/objet.8.1-2.135-149},
file = {:Users/leosilva/Documents/Estudo/Mestrado/Dissertacao/Referencias/10.1.1.24.3914.pdf:pdf},
issn = {12621137},
journal = {L'objet},
keywords = {evolution,m{\'{e}}triques du logiciel,patterns,reverse engineering,r{\'{e}}tro-,software metrics,software visualization,visualisation de programmes},
number = {1-2},
pages = {135--149},
title = {{Understanding software evolution using a combination of software visualization and software metrics$\backslash$n}},
volume = {8},
year = {2002}
}
@article{Wettel2011,
abstract = {applicability for this approach.},
archivePrefix = {arXiv},
arxivId = {arXiv:1011.1669v3},
author = {Wettel, Richard and Lanza, Michele and Robbes, Romain},
doi = {10.1145/1985793.1985868},
eprint = {arXiv:1011.1669v3},
file = {:Users/leosilva/Downloads/Wett2011a.pdf:pdf},
isbn = {9781450304450},
issn = {1098-6596},
journal = {Proceeding of the 33rd international conference on Software engineering - ICSE '11},
keywords = {and is widely used,empirical validation,in the context of,it has earned a,program comprehension,reputation as an effective,software maintenance,software visualization,technique},
pages = {551},
pmid = {25246403},
title = {{Software systems as cities}},
url = {http://portal.acm.org/citation.cfm?doid=1985793.1985868},
year = {2011}
}
@article{KazmanR.AbowdG.BassL.AndClements1996,
author = {{Kazman, R., Abowd, G., Bass, L., And Clements}, P.},
file = {:Users/leosilva/Documents/Estudo/Mestrado/Dissertacao/Referencias/GIT-CC-95-41.pdf:pdf},
journal = {IEEE Transactions on Software Engineering},
keywords = {applications of scenarios,software analysis methods,software architecture,software quality,ware architecture analysis},
pages = {1--24},
title = {{Scenario-Based Analysis of Software Architecture}},
year = {1996}
}
@article{Termeer2005,
abstract = {We present MetricView, a software visualization and exploration tool that combines traditional UML diagram visualization with metric visualization in an effective way. MetricView is very easy and natural to use for software architects and developers yet offers a powerful set of mechanisms that allow fine customization of the visualizations for getting specific insights. We discuss several visual and architectural design choices which turned out to be important in the construction of MetricView, and illustrate our approach with several results using real-life datasets},
author = {Termeer, Maurice and Lange, Christian F J and Telea, Alexandru and Chaudron, Michel R V},
doi = {10.1109/VISSOF.2005.1684298},
file = {:Users/leosilva/Documents/Estudo/Mestrado/Dissertacao/Referencias/01684298.pdf:pdf},
isbn = {0780395409},
journal = {Proceedings - VISSOFT 2005: 3rd IEEE International Workshop on Visualizing Software for Understanding and Analysis},
pages = {21--26},
title = {{Visual exploration of combined architectural and metric information}},
year = {2005}
}
@article{Wilde2016,
author = {Wilde, Evan and German, Daniel},
doi = {10.1109/VISSOFT.2016.18},
file = {:Users/leosilva/Documents/Estudo/Mestrado/Dissertacao/Referencias/07780151.pdf:pdf},
isbn = {9781509038503},
journal = {2016 IEEE 4rd Working Conference on Software Visualization, VISSOFT 2016 - Proceeding},
keywords = {Linux, git, data structures, tree data structures},
pages = {1--10},
title = {{Merge-tree : Visualizing the Integration of Commits into Linux}},
year = {2016}
}
@article{Greene2015a,
abstract = {Version control repositories contain a wealth of implicit information that can be used to answer many questions about a project's development process. However, this information is not directly accessible in the version control archives and must be extracted and visualized. This paper describes ConceptCloud, a flexible, interactive browser for SVN and Git repositories. The main novelty of our approach is the combination of an intuitive tag cloud visualization with an underlying concept lattice that provides a formal structure for navigation. ConceptCloud supports concurrent navigation in multiple linked but individually customizable tag clouds, which allows for multi-faceted repository browsing and for the construction of unique visualizations. We describe the mathematical foundations and implementation of our approach, and use ConceptCloud to quickly gain insight into the team structure and development process of two projects.},
author = {Greene, Gillian J. and Fischer, Bernd},
doi = {10.1109/VISSOFT.2015.7332415},
file = {:Users/leosilva/Downloads/vissoft15main-mainid10-p-585ed0e-25157-preprint.pdf:pdf},
isbn = {9781467375269},
journal = {2015 IEEE 3rd Working Conference on Software Visualization, VISSOFT 2015 - Proceedings},
keywords = {Browsers,Context,Data visualization,Lattices,Navigation,Software,Tag clouds},
number = {December},
pages = {56--65},
title = {{Interactive tag cloud visualization of software version control repositories}},
year = {2015}
}
@article{Novais2011,
abstract = {Software evolution is one of the most important topics in modern software engineering research. It deals with complex information and large amounts of data. Software visualization can be helpful in this scenario, helping to summarize, analyze and understand software evolution data. This paper presents SourceMiner Evolution (SME), a software tool that uses an interactive differential and temporal approach to visualize software evolution. The tool is implemented as an Eclipse plug-in and has four views that are assembled directly from the IDE AST. The views portray the software from different perspectives. One view shows how metrics of a chosen software entity evolves over time. The other three views show differential comparisons of any two versions of a system structure, dependency and inheritance properties.},
author = {Novais, Renato L. and Lima, Caio A N and {De F. Carneiro}, Glauco and Paulo, R. M S and Mendon{\c{c}}a, Manoel},
doi = {10.1109/VISSOF.2011.6069460},
file = {:Users/leosilva/Documents/Estudo/Mestrado/Dissertacao/Referencias/06069460.pdf:pdf},
isbn = {9781457708237},
journal = {Proceedings of VISSOFT 2011 - 6th IEEE International Workshop on Visualizing Software for Understanding and Analysis},
keywords = {Software evolution,Software visualization,differential views,multi-perspectives},
pages = {1--4},
title = {{An interactive differential and temporal approach to visually analyze software evolution}},
year = {2011}
}
@article{Petre2006,
abstract = {Software design is a realm of messy or “wicked” problems that are often too big, too ill-defined, and too complex for easy comprehension and solution (DeGrace and Stahl, 1998). Software itself is created, complex, abstract, and difficult to observe. Software is different from created physical artefacts, because it lacks their tangibility and visibility (e.g., What does a compiler look like? What is the size, weight and shape of an operating system?). Code may be manifest, but how code works must be discovered and understood. Nevertheless, software interacts with objects in the physical world, often in complex and sophisticated ways. Software is dynamic, and software developers must reason not just about its properties, but about its behaviour – potentially complex behaviour – in time. Moreover, software is created and maintained in a social and organisational context which itself changes over time. Software ages as this social and organisational context evolves: teams change, knowledge decays, documentation falls out of date, intentions and rationale are forgotten over time (Ball {\&} Eick, 1996). Software visualisation uses visual representations to make software more visible. Visualisation concerns the graphical (or semi-graphical) representation of information in order to assist human comprehension of and reasoning about that information. There are a number of loosely distinguished themes within visualisation, among them information visualisation (representation of large data sets), software visualisation (visualisation for software engineering), and program or algorithm visualisation (representation of the structure and behaviour of algorithms for educational purposes). Despite their different foci, they have much in common, in terms of issues, techniques, and vocabulary. For example, visualization for software engineering must also include representation of the structure and behaviour of algorithms, but typically within the context of large-scale software development and maintenance, rather than the educational context of first understanding the algorithm. This paper focuses on software visualisation, the application of graphical techniques to represent different aspects of software – such as the source code, the software structure, runtime behaviour, component interaction, or software evolution – in order to reveal patterns and behaviours that inform software comprehension through all stages of software development. Software visualisation can range from simple ‘pretty printers', which use typographic enhancements such as indentation and colour coding (e.g., Baecker and Marcus, 1990), to 3D ‘landscapes' representing the structure of large software systems, to multiple, linked, dynamic visualisations of the interaction of system components at runtime. Price, Baecker and Small (1998) defined software visualisation as “{\ldots}the use of the crafts of typography, graphic design, animation, and cinematography with modern human-computer interaction technology to facilitate both the human understanding and effective use of computer software”. Visualisations may be based on static structures (views of the source code), or generated from dynamic data generated at runtime (views of execution, whether data flow or control flow). Software visualisation has it roots in earliest software development practice, when programmers watched the lights on the computer's control panel and listened to the sounds of disk access to try to understand what the program was doing in the absence of other perceivable cues. This paper presents a brief review of visualisation of software for software professionals. It is by no means comprehensive, but rather is intended as a light overview, to provide entry points into the literature, indicate the current state of the art, and discuss some of the persistent issues. It does not describe systems in detail, rather it considers factors that relate software visualisations to the tasks involved in software development, and it signals some (but certainly not all) systems that address particular perspectives.},
author = {Petre, M and Quincey, E De},
doi = {10.1.1.127.6350},
file = {:Users/leosilva/Documents/Estudo/Mestrado/Dissertacao/Referencias/A{\_}gentle{\_}overview{\_}of{\_}software{\_}visualisat.pdf:pdf},
journal = {PPIG News Letter},
keywords = {software visualisation},
number = {September},
pages = {1 -- 10},
title = {{A gentle overview of software visualisation}},
url = {http://www.labri.fr/perso/fleury/courses/PdP/SoftwareVisualization/1-overview-swviz.pdf},
year = {2006}
}
@article{Lanza2001,
abstract = {One of the major problems in software evolution is coping with the complexity which stems from the huge amount of data that must be considered. The current approaches to deal with that problem all aim at a reduction of complexity and a filtering of the relevant information. In this paper we propose an approach based on a com- bination of software visualization and software metrics which we have already successfully applied in the field of software reverse engineering. Using this approach we discuss a simple and effective way to visualize the evolution of software systems which helps to recover the evolution of object oriented software systems.},
author = {Lanza, M},
doi = {10.1145/602461.602467},
file = {:Users/leosilva/Documents/Estudo/Mestrado/Dissertacao/Referencias/STMHeima4EvolMatrix.pdf:pdf},
isbn = {1581135084},
journal = {Proceedings of the 4th international workshop on principles of software evolution},
keywords = {and then show an,example matrix,in this section we,present the evolution matrix,reverse engineering,software metrics,software visualization,visualization technique we use,we first discuss the},
pages = {37--42},
title = {{The evolution matrix: Recovering software evolution using software visualization techniques}},
url = {http://portal.acm.org/citation.cfm?id=602461.602467},
year = {2001}
}
@article{Choudhury2011,
abstract = {We present a system for visualizing memory reference traces, the records of the memory transactions performed by a program at runtime. The visualization consists of a structured layout representing the levels of a cache and a set of data glyphs representing the pieces of data in memory being operated on during application runtime. The data glyphs move in response to events generated by a cache simulator, indicating their changing residency in the various levels of the memory hierarchy. Within the levels, the glyphs arrange themselves into higher-order shapes representing the structure of the cache levels, including the composition of their associative cache sets and eviction ordering. We make careful use of different visual channels, including structure, motion, color, and size, to convey salient events as they occur. Our abstract visualization provides a high-level, global view of memory behavior, while giving insight about important events that may help students or software engineers to better understand their software's performance and behavior.},
author = {Choudhury, A. N M Imroz and Rosen, Paul},
doi = {10.1109/VISSOF.2011.6069452},
file = {:Users/leosilva/Documents/Estudo/Mestrado/Dissertacao/Referencias/Choudhury.2011.VisSoft.pdf:pdf},
isbn = {9781457708237},
journal = {Proceedings of VISSOFT 2011 - 6th IEEE International Workshop on Visualizing Software for Understanding and Analysis},
title = {{Abstract visualization of runtime memory behavior}},
year = {2011}
}
@article{Sakamoto2012,
abstract = {We have previously proposed a service oriented framework, named SO-MSR, which applied SOA (service oriented architecture) for conducting the MSR (mining software repository). The principal concept of SO-MSR is to hide complex and complicated mining procedures to end-users for practical use of MSR. Following the SO-MSR, we have also developed Metrics WebAPI which is a web service for metrics measurement. The purpose of this paper is to evaluate the benefits and limitations of SO-MSR and Metrics WebAPI through a development of client system of Metrics WebAPI. To achieve the goal, we develop a consumer mash up application, named Metrics Viewer, which integrates Metrics WebAPI and Google Chart Tools. This system is a Ajax web application for visualizing software evolution from a revision control system repository. Through the development experiment, we have confirmed that the SO-MSR enables us easy and rapid implementation of client system, easily integrating with other web services and light-weight execution system.},
author = {Sakamoto, Yasutaka and Matsumoto, Shinsuke and Nakamura, Masahide},
doi = {10.1109/IWESEP.2012.16},
file = {:Users/leosilva/Documents/Estudo/Mestrado/Dissertacao/Referencias/06363294.pdf:pdf},
isbn = {9780769548661},
journal = {Proceedings - 2012 4th International Workshop on Empirical Software Engineering in Practice, IWESEP 2012},
keywords = {MetricsViewer,MetricsWebAPI,SO-MSR,mining software repository,service oriented architecture,visualization,web application},
pages = {35--39},
title = {{Integrating service oriented MSR framework and google chart tools for visualizing software evolution}},
year = {2012}
}
@article{Ambros2007,
author = {Ambros, Marco D and Lanza, Michele},
doi = {10.1109/CSMR.2007.17},
file = {:Users/leosilva/Documents/Estudo/Mestrado/Dissertacao/Referencias/10.1.1.719.5807.pdf:pdf},
journal = {11th European Conference on Software Maintenance and Reengineering (CSMR'07)},
pages = {4--5},
title = {{BugCrawler: Visualizing Evolving Software Systems}},
url = {http://ieeexplore.ieee.org/document/4145055/},
year = {2007}
}
@article{Pablo2013,
abstract = {Understanding and minimizing the impact of software changes on performance are both challenging and essential when developing software. Unfortunately, current code execution profilers do not offer efficient abstractions and adequate representations to keep track of performance across multiple versions. Consequently, understanding the cause of a slow execution stemming from a software evolution is often realized in an ad hoc fashion. We have designed Rizel, a code profiler that identifies the root of performance variations thanks to an expressive and intuitive visual representation. Rizel highlights variation of executions and time distribution between multiple software versions. Rizel is available for the Pharo programming language under the MIT License. Copyright {\textcopyright} 2013 ACM.},
author = {Pablo, J. and Alcocer, S. and Bergel, A.},
doi = {10.1145/2501543.2501549},
file = {:Users/leosilva/Documents/Estudo/Mestrado/Dissertacao/Referencias/p38-alcocer.pdf:pdf},
isbn = {9781450323116},
journal = {International Workshop on Principles of Software Evolution (IWPSE)},
keywords = {Performance,Profiling,Software evolution,Software visualization},
number = {Dcc},
pages = {38--42},
title = {{Tracking performance failures with rizel}},
year = {2013}
}
@article{Herman2000,
abstract = {This is a survey on graph visualization and navigation techniques,$\backslash$nas used in information visualization. Graphs appear in numerous$\backslash$napplications such as Web browsing, state-transition diagrams, and data$\backslash$nstructures. The ability to visualize and to navigate in these$\backslash$npotentially large, abstract graphs is often a crucial part of an$\backslash$napplication. Information visualization has specific requirements, which$\backslash$nmeans that this survey approaches the results of traditional graph$\backslash$ndrawing from a different perspective},
author = {Herman, Ivan and Melan{\c{c}}on, Guy and Marshall, M. Scott},
doi = {10.1109/2945.841119},
file = {:Users/leosilva/Documents/Estudo/Mestrado/Dissertacao/Referencias/herman2000.pdf:pdf},
isbn = {1077-2626 VO - 6},
issn = {10772626},
journal = {IEEE Transactions on Visualization and Computer Graphics},
number = {1},
pages = {24--43},
pmid = {841119},
title = {{Graph visualization and navigation in information visualization: a survey}},
volume = {6},
year = {2000}
}
@article{Novais2013,
abstract = {Background Software evolution is an important topic in software engineering. It generally deals with large amounts of data, as one must look at whole project histories as opposed to their current snapshot. Software visualization is the field of software engineering that aims to help people to understand software through the use of visual resources. It can be effectively used to analyze and understand the large amount of data produced during software evolution. Objective This study investigates Software Evolution Visualization (SEV) approaches, collecting evidence about how SEV research is structured, synthesizing current evidence on the goals of the proposed approaches and identifying key challenges for its use in practice. Methods A mapping study was conducted to analyze how the SEV area is structured. Selected primary studies were classified and analyzed with respect to nine research questions. Results SEV has been used for many different purposes, especially for change comprehension, change prediction and contribution analysis. The analysis identified gaps in the studies with respect to their goals, strategies and approaches. It also pointed out to a widespread lack of empirical studies in the area. Conclusion Researchers have proposed many SEV approaches during the past years, but some have failed to clearly state their goals, tie them back to concrete problems, or formally validate their usefulness. The identified gaps indicate that there still are many opportunities to be explored in the area. ?? 2013 Elsevier B.V. All rights reserved.},
author = {Novais, Renato Lima and Torres, Andr{\'{e}} and Mendes, Thiago Souto and Mendon{\c{c}}a, Manoel and Zazworka, Nico},
doi = {10.1016/j.infsof.2013.05.008},
file = {:Users/leosilva/Documents/Estudo/Mestrado/Dissertacao/Referencias/1-s2.0-S0950584913001298-main.pdf:pdf},
isbn = {ISO/TR 20514},
issn = {09505849},
journal = {Information and Software Technology},
keywords = {Software evolution,Software visualization,Systematic mapping study},
number = {11},
pages = {1860--1883},
publisher = {Elsevier B.V.},
title = {{Software evolution visualization: A systematic mapping study}},
url = {http://dx.doi.org/10.1016/j.infsof.2013.05.008},
volume = {55},
year = {2013}
}
@article{Sharafi2011,
abstract = {The visualization of software systems allows a software developer to build a mental model of the program supporting her to better understand its design and functionality. This research aims at studying current visualization techniques and practices to propose a set of principles for designing effective software architecture visualization techniques, focusing on their support for program comprehension. The research will be carried out in three main phases. First, we will complement current works by proposing a taxonomy of visualization techniques. The second contribution will be to identify different requirements and characteristics of architecture visualization techniques. Finally, to evaluate software visualization's usability and effectiveness in practice, we will measure the performance of developers in terms of their percentage of the correct answers and effort developers spend to answer given questions. To compute the developer's effort, we will use eye-tracker's data. {\&}copy; 2011 IEEE.},
author = {Sharafi, Zohreh},
doi = {10.1109/ICPC.2011.40},
file = {:Users/leosilva/Documents/Estudo/Mestrado/Dissertacao/Referencias/Zohreh-V3.pdf:pdf},
isbn = {9780769543987},
journal = {IEEE International Conference on Program Comprehension},
keywords = {Software architecture,Software visualization,eye tracking,program comprehension,usability},
number = {June},
pages = {254--257},
title = {{A systematic analysis of software architecture visualization techniques}},
year = {2011}
}
@inproceedings{Wang:2006:VLH:1124772.1124851,
address = {New York, NY, USA},
author = {Wang, Weixin and Wang, Hui and Dai, Guozhong and Wang, Hongan},
booktitle = {Proceedings of the SIGCHI Conference on Human Factors in Computing Systems},
doi = {10.1145/1124772.1124851},
isbn = {1-59593-372-7},
keywords = {circle packing,file system,nested circles,tree visualization},
pages = {517--520},
publisher = {ACM},
series = {CHI '06},
title = {{Visualization of Large Hierarchical Data by Circle Packing}},
url = {http://doi.acm.org/10.1145/1124772.1124851},
year = {2006}
}
@article{Steinbruckner2010b,
abstract = {In this paper we describe a systematic approach to utilize the city metaphor for the visualization of large software systems as evolving software cities. The main contribution is a new layout approach which explicitly takes the development history of software systems into account and makes history directly visible in the layouts. These layouts incrementally evolve in a very smooth and stable way during the development of the represented software system. They are used as a visualization platform for integrating a large variety of product and process data and thus create a coherent set of specialized visualizations. To illustrate this we present some example maps capturing specific development history aspects.},
author = {Steinbr{\"{u}}ckner, Frank and Lewerentz, Claus},
doi = {10.1145/1879211.1879239},
file = {:Users/leosilva/Documents/Estudo/Mestrado/Dissertacao/Referencias/p193-steinbruckner.pdf:pdf},
isbn = {978-1-4503-0028-5},
issn = {15437221},
journal = {Proc. 5th Int. Symp. Softw. Vis.},
keywords = {software cities,software evolution,software landscapes,software visualization},
pages = {193--202},
title = {{Representing development history in software cities}},
url = {http://dl.acm.org/citation.cfm?id=1879211.1879239},
year = {2010}
}
@article{Panas2007,
abstract = {Software is among the most complex human artifacts, and visualization is widely acknowledged as important to understanding software. In this paper, we consider the problem of understanding a software system's architecture through visualization. Whereas traditional visualizations use multiple stakeholder-specific views to present different kinds of task- specific information, we propose an additional visualization technique that unifies the presentation of various kinds of architecture-level information, thereby allowing a variety of stakeholders to quickly see and communicate current development, quality, and costs of a software system. For future empirical evaluation of multi-aspect, single-view architectural visualizations, we have implemented our idea in an existing visualization tool, Vizz3D. Our implementation includes techniques, such as the use of a city metaphor, that reduce visual complexity in order to support single-view visualizations of large-scale programs.},
author = {Panas, Thomas and Epperly, Thomas and Quinlan, Daniel and S{\ae}bj{\o}rnsen, Andreas and Vuduc, Richard},
doi = {10.1109/ICECCS.2007.20},
file = {:Users/leosilva/Documents/Estudo/Mestrado/Dissertacao/Referencias/panas2007.pdf:pdf},
isbn = {0769528953},
journal = {Proceedings of the IEEE International Conference on Engineering of Complex Computer Systems, ICECCS},
number = {Iceccs},
pages = {217--226},
title = {{Communicating software architecture using a unified single-view visualization}},
year = {2007}
}
@article{Greene2015,
abstract = {Version control repositories contain a wealth of implicit information that can be used to answer many questions about a project's development process. However, this information is not directly accessible in the version control archives and must be extracted and visualized. This paper describes ConceptCloud, a flexible, interactive browser for SVN and Git repositories. The main novelty of our approach is the combination of an intuitive tag cloud visualization with an underlying concept lattice that provides a formal structure for navigation. ConceptCloud supports concurrent navigation in multiple linked but individually customizable tag clouds, which allows for multi-faceted repository browsing and for the construction of unique visualizations. We describe the mathematical foundations and implementation of our approach, and use ConceptCloud to quickly gain insight into the team structure and development process of two projects.},
author = {Burch, Michael and Munz, Tanja and Beck, Fabian and Weiskopf, Daniel and Ens, Barrett and Rea, Daniel and Shpaner, Roiy and Hemmati, Hadi and Young, James E. and Irani, Pourang and Greene, Gillian J. and Fischer, Bernd and Kula, Raula Gaikovina and {De Roover}, Coen and German, Daniel and Ishio, Takashi and Inoue, Katsuro and {Van Hees}, Rinse and Hage, Jurriaan},
doi = {10.1109/VISSOFT.2014.28},
file = {:Users/leosilva/Documents/Estudo/Mestrado/Dissertacao/Referencias/ChronoTwigger{\_}Final{\_}Version.pdf:pdf;:Users/leosilva/Documents/Estudo/Mestrado/Dissertacao/Referencias/VISSOFT2014.pdf:pdf;:Users/leosilva/Documents/Estudo/Mestrado/Dissertacao/Referencias/07332415.pdf:pdf;:Users/leosilva/Documents/Estudo/Mestrado/Dissertacao/Referencias/07332410.pdf:pdf;:Users/leosilva/Documents/Estudo/Mestrado/Dissertacao/Referencias/vissoft15-developerrivers{\_}01.pdf:pdf},
isbn = {9781467375269},
journal = {2015 IEEE 3rd Working Conference on Software Visualization, VISSOFT 2015 - Proceedings},
keywords = {3D visualization,Browsers,Co-evolution,Color,Context,Data visualization,Lattices,Layout,Measurement,Monitoring,Navigation,Rivers,Software,Software Evolution,Software Maintenance,Software Reuse,Software algorithms,Software systems,Tag clouds,Visualization,co-change,information visualization,mining software repositories,temporal data visualization,visual analytics},
pages = {56--65},
title = {{ChronoTwigger: A visual analytics tool for understanding source and test co-evolution}},
year = {2015}
}
@article{Oliva2011,
author = {Oliva, Gustavo and Aniche, Mauricio and Gerosa, Marco and Oliva, Gustavo and Aniche, Mauricio},
file = {:Users/leosilva/Documents/Estudo/Mestrado/Dissertacao/Referencias/softwareevolution-updatedversion-141021093057-conversion-gate01.pdf:pdf},
title = {{Evolu{\c{c}}{\~{a}}o de Software Instrutores}},
year = {2011}
}
@article{Johnson1991,
author = {Johnson, Brian and Shneiderman, Ben},
file = {:Users/leosilva/Documents/Estudo/Mestrado/Dissertacao/Referencias/370.pdf:pdf},
journal = {Proceedings., IEEE Conference on},
pages = {284--291},
title = {{Tree-maps: A space-filling approach to the visualization of hierarchical information structures}},
year = {1991}
}
@article{Whaley2000,
abstract = {This paper describes a portable and efficient sampling-based online measurement system for production-level Java virtual machines. This system is designed to provide continuous real time system performance measurements to a dynamic compiler, which can use these measurements to target frequently executed and time-consuming code for optimization and to make more informed optimization decisions. Because the system has very low overhead, it can be run continuously, providing a feedback mechanism to the dynamic compiler. This system utilizes a novel data structure, the partial calling context tree (PCCT), which allows the efficient encoding of approximate context-sensitive profile information. The PCCT is organized such that both incremental updates and extracting the important information are efficient operations. This online measurement system has been implemented in a cross-platform industry-leading Java Just-In-Time compiler. We present detailed performance results on a variety of platforms that show that the system is not only efficient enough to be used continuously in a production environment (2-4{\%} slowdown for most applications) but is also surprisingly accurate in the data that it collects (typically ≥90{\%} accurate).},
author = {Whaley, J},
doi = {10.1145/337449.337483},
file = {:Users/leosilva/Documents/Estudo/Mestrado/Dissertacao/Referencias/p78-whaley.pdf:pdf},
isbn = {1581132883},
journal = {ACM 2000 Java Grande Conference},
pages = {78--87},
title = {{A portable sampling-based profiler for Java virtual machines}},
url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-0034593387{\&}partnerID=40{\&}md5=f1a0c62239f86fcad01225e85de843c0},
year = {2000}
}
@article{Pinto2015a,
annote = {NULL},
author = {Pinto, Felipe and Kulesza, Uira and Treude, Christoph},
doi = {10.1109/SCAM.2015.7335416},
file = {:Users/leosilva/Documents/Estudo/Mestrado/Dissertacao/Referencias/07335416.pdf:pdf},
isbn = {9781467375290},
journal = {2015 IEEE 15th International Working Conference on Source Code Analysis and Manipulation, SCAM 2015 - Proceedings},
keywords = {Performance,dynamic analysis,execution time,repository mining,scenario},
pages = {201--210},
title = {{Automating the performance deviation analysis for multiple system releases: An evolutionary study}},
year = {2015}
}
@article{Islam2010,
author = {Islam, Syed and Krinke, Jens and Binkley, David},
file = {:Users/leosilva/Documents/Estudo/Mestrado/Dissertacao/Referencias/softvis10.pdf:pdf},
isbn = {9781450300285},
keywords = {clustering,dependence,program comprehension,program slicing,re-engineering,reverse engineering,visualization},
pages = {93--102},
title = {{Dependence Cluster Visualization}},
year = {2010}
}
@article{Ball1996,
author = {Ball, Thomas and Eick, S.G.},
doi = {10.1109/2.488299},
file = {:Users/leosilva/Documents/Estudo/Mestrado/Dissertacao/Referencias/BallEick1996.pdf:pdf},
issn = {00189162},
journal = {Computer},
keywords = {legacy code,profiling,program comprehension,slicing,software visualization,version history},
month = {apr},
number = {4},
pages = {33--43},
title = {{Software visualization in the large}},
url = {http://ieeexplore.ieee.org/document/488299/},
volume = {29},
year = {1996}
}
@article{Burch2015,
abstract = {Work processes involving dozens or hundreds of collaborators are complex and difficult to manage. Problems within the process may have severe organizational and financial consequences. Visualization helps monitor and analyze those processes. In this paper, we study the development of large software systems as an example of a complex work process. We introduce Developer Rivers, a timeline-based visualization technique that shows how developers work on software modules. The flow of developers' activity is visualized by a river metaphor: activities are transferred between modules represented as rivers. Interactively switching between hierarchically organized modules and workload metrics allows for exploring multiple facets of the work process. We study typical development patterns by applying our visualization to Python and the Linux kernel.},
author = {Burch, Michael and Munz, Tanja and Beck, Fabian and Weiskopf, Daniel},
doi = {10.1109/VISSOFT.2015.7332421},
file = {:Users/leosilva/Documents/Estudo/Mestrado/Dissertacao/Referencias/vissoft15-developerrivers{\_}01.pdf:pdf},
isbn = {9781467375269},
journal = {2015 IEEE 3rd Working Conference on Software Visualization, VISSOFT 2015 - Proceedings},
keywords = {Color,Data visualization,Monitoring,Rivers,Software systems,Visualization},
pages = {116--124},
title = {{Visualizing work processes in software engineering with developer rivers}},
year = {2015}
}
@inproceedings{Malik2013,
abstract = {Load testing is one of the means for evaluating the performance of Large Scale Systems (LSS). At the end of a load test, performance analysts must analyze thousands of performance counters from hundreds of machines under test. These performance counters are measures of run-time system properties such as CPU utilization, Disk I/O, memory consumption, and network traffic. Analysts observe counters to find out if the system is meeting its Service Level Agreements (SLAs). In this paper, we present and evaluate one supervised and three unsupervised approaches to help performance analysts to 1) more effectively compare load tests in order to detect performance deviations which may lead to SLA violations, and 2) to provide them with a smaller and manageable set of important performance counters to assist in root-cause analysis of the detected deviations. Our case study is based on load test data obtained from both a large scale industrial system and an open source benchmark application. The case study shows, that our wrapper-based supervised approach, which uses a search-based technique to find the best subset of performance counters and a logistic regression model for deviation prediction, can provide up to 89{\%} reduction in the set of performance counters while detecting performance deviations with few false positives (i.e., 95{\%} average precision). The study also shows that the supervised approach is more stable and effective than the unsupervised approaches but it has more overhead due to its semi-automated training phase. {\&}copy; 2013 IEEE.},
author = {Malik, Haroon and Hemmati, Hadi and Hassan, Ahmed E},
booktitle = {Proceedings - International Conference on Software Engineering},
doi = {10.1109/ICSE.2013.6606651},
file = {:Users/leosilva/Downloads/SEIP13Preprint.pdf:pdf},
isbn = {9781467330763},
issn = {02705257},
keywords = {Machine Learning,Performance,Signature},
pages = {1012--1021},
title = {{Automatic detection of performance deviations in the load testing of Large Scale Systems}},
url = {https://doi.org/10.1109/ICSE.2013.6606651},
year = {2013}
}
@inproceedings{Alam2007,
abstract = {This paper presents the Evospaces reverse-engineering tool that represents the architecture and metrics of complex software systems in a 3D virtual world. The main goal of our project is to exploit familiar metaphors (analogical representations borrowed from another domain) and sophisticated interactions modes to help the user understand complex systems. First, we present the general architecture of the Evospaces tool. Second, we show the metaphors we have implemented to help the user to quickly get an overview of a complex system. Then we present the interaction mode we designed to let the user explore such a complex system. Finally, we show an example of a virtual space we have designed to represent the architecture of Mozilla. We conclude with an account of our current research directions. The main contributions of this paper are the metaphors that we have used and the types of interaction modes we have implemented. They represent a real contribution to the set of tools that can help a maintenance engineer to understand a large system such as Mozilla. Copyright {\&}copy; (2007) by Knowledge Systems Institute (KSI).},
author = {Alam, Sazzadul and Dugerdil, Philippe},
booktitle = {19th International Conference on Software Engineering and Knowledge Engineering, SEKE 2007},
file = {:Users/leosilva/Documents/Estudo/Mestrado/Dissertacao/Referencias/evospaces{\_}3d{\_}visualization{\_}of{\_}software{\_}architecture.pdf:pdf},
isbn = {9781627486613},
keywords = {Architecture,Knowledge engineering,Large scale sys},
number = {fig 1},
pages = {500--505},
title = {{EvoSpaces: 3D visualization of software architecture}},
year = {2007}
}
@article{Wettel2008,
abstract = {The goal of reverse engineering is to obtain a mental model of software systems. However, evolution adds another dimension to their implicit complexity, effectively making them moving targets: The evolution of software systems still remains an intangible and complex process. Metrics have been extensively used to quantify various facets of evolution, but even the usage of complex metrics often leads to overly simplistic insights, thus failing at adequately characterizing the complex evolutionary processes.We present an approach based on real-time interactive 3D visualizations, whose goal is to render the structural evolution of object-oriented software systems at both a coarse-grained and a fine-grained level. By providing insights into a system's history, our visualizations allow us to reason about the origins and the causalities which led to the current state of a system. We illustrate our approach on three large open-source systems and report on our findings, which were confirmed by developers of the studied systems.},
author = {Wettel, Richard and Lanza, Michele},
doi = {10.1109/WCRE.2008.55},
file = {:Users/leosilva/Documents/Estudo/Mestrado/Dissertacao/Referencias/10.1.1.640.4308.pdf:pdf},
isbn = {0769534295},
issn = {10951350},
journal = {Proceedings - Working Conference on Reverse Engineering, WCRE},
pages = {219--228},
title = {{Visual exploration of large-scale system evolution}},
year = {2008}
}
@article{Plaisant2004,
abstract = {As the field of information visualization matures, the tools and ideas described in our research publications are reaching users. The reports of usability studies and controlled experiments are helpful to understand the potential and limitations of our tools, but we need to consider other evaluation approaches that take into account the long exploratory nature of users tasks, the value of potential discoveries or the benefits of overall awareness. We need better metrics and benchmark repositories to compare tools, and we should also seek reports of successful adoption and demonstrated utility.},
author = {Plaisant, Catherine},
doi = {10.1145/989863.989880},
file = {:Users/leosilva/Documents/Estudo/Mestrado/Dissertacao/Referencias/2004-19.pdf:pdf},
isbn = {1581138679},
journal = {Proceedings of the working conference on Advanced visual interfaces - AVI '04},
keywords = {adoption,e-commerce users are getting,evaluation,exposed to,figure 1,investment,return on,technology transfer,usability,usefulness,user studies},
pages = {109--116},
title = {{The challenge of information visualization evaluation}},
url = {http://portal.acm.org/citation.cfm?doid=989863.989880},
year = {2004}
}
@article{Mostafa2009,
author = {Mostafa, Nagy and Krintz, Chandra},
doi = {10.1145/1596655.1596682},
file = {:Users/leosilva/Documents/Estudo/Mestrado/Dissertacao/Referencias/10.1.1.154.4201.pdf:pdf},
isbn = {9781605585987},
journal = {Proceedings of the 7th International Conference on Principles and Practice of Programming in Java - PPPJ '09},
keywords = {calling context tree,performance-aware revision control,profiling},
pages = {162--171},
title = {{Tracking performance across software revisions}},
url = {http://portal.acm.org/citation.cfm?doid=1596655.1596682},
year = {2009}
}
@phdthesis{ApacheWi,
author = {Wicket, Apache},
title = {{Wicket}},
url = {https://wicket.apache.org},
year = {2016}
}
@article{Wettel2009,
abstract = {The comprehensive understanding of today's software systems is a daunting activity, because of the sheer size and complexity that such systems exhibit. Moreover, software systems evolve, which dramatically increases the amount of data one needs to analyze in order to gain insights into such systems. Indeed, software complexity is recognized as one of the major challenges to the development and maintenance of industrial-size software projects. Our vision is a 3D visualization approach which helps software engineers build knowledge about their systems. We settled on an intuitive metaphor, which depicts software systems as cities. To validate the ideas emerging from our research, we implemented a tool called CodeCity. We devised a set of visualization techniques to support tasks related to program comprehension, design quality assessment, and evolution analysis, and applied them on large open-source systems written in Java, C++, or Smalltalk. Our next research goals are enriching our metaphor with meaningful representations for relations and encoding higher-level information.},
author = {Wettel, Richard},
doi = {10.1109/ICSE-COMPANION.2009.5071029},
file = {:Users/leosilva/Documents/Estudo/Mestrado/Dissertacao/Referencias/Wettel09a-icse-doctoral.pdf:pdf},
isbn = {9781424434947},
journal = {2009 31st International Conference on Software Engineering - Companion Volume, ICSE 2009},
pages = {391--394},
title = {{Visual exploration of large-scale evolving software}},
year = {2009}
}
@article{Cornelissen2009,
author = {Cornelissen, B and Zaidman, A and van Deursen, A and Moonen, L and Koschke, R},
doi = {10.1109/TSE.2009.28},
file = {:Users/leosilva/Documents/Estudo/Mestrado/Dissertacao/Referencias/TUD-SERG-2008-033.pdf:pdf},
issn = {0098-5589},
journal = {Transactions on Software Engineering},
keywords = {Dynamic Analysis,Program Comprehension},
number = {5},
pages = {684--702},
title = {{A Systematic Survey of Program Comprehension through Dynamic Analysis}},
volume = {35},
year = {2009}
}
@article{Duszynski2009,
abstract = {Fraunhofer SAVE (software architecture visualization and evaluation) is a tool for analyzing and optimizing the architecture of implemented software systems. SAVE is a joint development between Fraunhofer IESE (Institute for Experimental Software Engineering IESE in Kaiserslautern, Germany) and Fraunhofer Center Maryland (Center for Experimental Software Engineering in College Park, Maryland, USA). In this work we describe the capabilities of the tool to assure compliance of existing systems with their architecture. In particular, we show how compliance checking features of SAVE work to assure compliance with structural and behavioral architectural views, to assure compliance among variants in a product line context, and to incorporate constructive compliance checking to enable built-in compliance during development and evolution.},
author = {Duszynski, Slawomir and Knodel, Jens and Lindvall, Mikael},
doi = {10.1109/CSMR.2009.52},
file = {:Users/leosilva/Documents/Estudo/Mestrado/Dissertacao/Referencias/04812786.pdf:pdf},
isbn = {9780769535890},
issn = {15345351},
journal = {Proceedings of the European Conference on Software Maintenance and Reengineering, CSMR},
keywords = {Compliance checking,Reverse engineering,SAVE,Software architecture,Visualization},
pages = {323--324},
title = {{SAVE: Software architecture visualization and evaluation}},
year = {2009}
}
@article{Ghanam2008,
abstract = {Understanding the software architecture is a vital step towards building$\backslash$nand maintaining software systems. But software architecture is an$\backslash$nintangible conceptual entity. Therefore, it is hard to comprehend$\backslash$na software architecture without a visual mapping that reduces the$\backslash$nburden on the human brain. Visualizing software architecture has$\backslash$nbeen one of the most important topics in software visualization.$\backslash$nNot only are architects interested in this visualization but also$\backslash$ndevelopers, testers, project managers and even customers. This paper$\backslash$nis a survey on recent and key literature on software architecture$\backslash$nvisualization. It touches on efforts that defined what characteristics$\backslash$nan effective visualization should have. It compares various efforts$\backslash$nin this discipline according to taxonomies such as dimensionality,$\backslash$nmultiplicity of views and use of metaphors. The paper also discusses$\backslash$ntrends and patterns in recent research and addresses research questions$\backslash$nthat are still open for further investigation.},
author = {Ghanam, Yaser and Carpendale, Sheelagh},
doi = {http://hdl.handle.net/1880/46648},
file = {:Users/leosilva/Documents/Estudo/Mestrado/Dissertacao/Referencias/00b4952a78a711c266000000.pdf:pdf},
journal = {University of Calgary, Tech. Rep},
title = {{A survey paper on software architecture visualization}},
url = {http://dspace.ucalgary.ca/bitstream/1880/46648/1/2008-906-19.pdf?origin=publication{\_}detail},
year = {2008}
}
@article{Benomar2013,
abstract = {Interactive software visualization offers a promising support for program comprehension, including program dynamicity. We present, the extension of an existing visualization tool with heat maps to explore the time and other dimensions of software. To this end, we first propose a framework to unify the two main software dynamicities, execution and evolution. Then, this unified framework is exploited to define a visualization environment based on heat maps. We illustrate our approach on two comprehension tasks: understanding the behavior of programmers during the evolution of an application and understanding class contributions in use cases. The case studies show that the heat-map metaphor contributes to answer, more easily, many of the questions important to program comprehension.},
author = {Benomar, Omar and Sahraoui, Houari and Poulin, Pierre},
doi = {10.1109/VISSOFT.2013.6650524},
file = {:Users/leosilva/Documents/Estudo/Mestrado/Dissertacao/Referencias/Benomar-2013-VSDHM.pdf:pdf},
isbn = {9781479914579},
journal = {2013 1st IEEE Working Conference on Software Visualization - Proceedings of VISSOFT 2013},
title = {{Visualizing software dynamicities with heat maps}},
year = {2013}
}
@article{Byelas2009,
abstract = {We present a new method for the combined visualization of software architecture diagrams, such as UML class diagrams or component diagrams, and software metrics defined on groups of diagram elements. Our method extends an existing rendering technique for the so-called areas of interest in system architecture diagrams to visualize several metrics, possibly having missing values, defined on overlapping areas of interest. For this, we use a solution that combines texturing, blending, and smooth scattered-data point interpolation. Our new method simplifies the task of visually correlating the distribution and outlier values of a multivariate metric dataset with a system's structure. We demonstrate the application of our method on component and class diagrams extracted from real-world systems.},
author = {Byelas, Heorhiy and Telea, Alexandru},
doi = {10.1109/PACIFICVIS.2009.4906835},
file = {:Users/leosilva/Documents/Estudo/Mestrado/Dissertacao/Referencias/ced79ffa0cdf5de28a1716ebc2fe79048f29.pdf:pdf},
isbn = {9781424444045},
issn = {1045-926X},
journal = {IEEE Pacific Visualization Symposium, PacificVis 2009 - Proceedings},
keywords = {Computer-aided software engineering,I.3.4 [graphics utilities]: Graphics editors,Paint systems; D.2.2 [design tools and techniques]},
pages = {33--40},
title = {{Visualizing metrics on areas of interest in software architecture diagrams}},
year = {2009}
}
@article{Holt1996,
abstract = {Large and long lived software systems, sometimes called legacy$\backslash$nsystems, must evolve if they are to remain useful. Too often, it is$\backslash$ndifficult to control or to understand this evolution. The paper presents$\backslash$nan approach to visualizing software structural change. A visualization$\backslash$ntool, called GASE (Graphical Analyzer for Software Evolution), has been$\backslash$nused to elucidate the architectural changes in a sequence of eleven$\backslash$nrevisions of an eighty thousand line industrial software system},
author = {Holt, R. and Pak, J.Y.},
doi = {10.1109/WCRE.1996.558900},
file = {:Users/leosilva/Documents/Estudo/Mestrado/Dissertacao/Referencias/10.1.1.44.3276.pdf:pdf},
isbn = {0-8186-7674-4},
journal = {Proceedings of WCRE '96: 4rd Working Conference on Reverse Engineering},
pages = {163--167},
title = {{GASE: visualizing software evolution-in-the-large}},
year = {1996}
}
@book{Molyneaux2009,
abstract = {This practical book provides a step-by-step approach to testing mission-critical applications for scalability and performance before they're deployed -- a vital topic to which other books devote one chapter, if that. Businesses today live and die by network applications and web services. Because of the increasing complexity of these programs, and the pressure to deploy them quickly, many professionals don't take the time to ensure that they'll perform well and scale effectively. The Art of Application Performance Testing explains the complete life cycle of the testing process, and demonstrates best practices to help you plan, gain approval for, coordinate, and conduct performance tests on your applications. With this book, you'll learn to: Set realistic performance testing goals Implement an effective application performance testing strategy Interpret performance test results Cope with different application technologies and architectures Use automated performance testing tools Test traditional local applications, web-based applications, and web services (SOAs) Recognize and resolves issues that are often overlooked in performance tests Written by a consultant with 30 years of experience in the IT industry and over 12 years experience with performance testing, this easy-to-read book is illustrated with real-world examples and packed with practical advice. The Art of Application Performance Testing thoroughly explains the pitfalls of an inadequate testing strategy and offers you a robust, structured approach for ensuring that your applications perform well and scale effectively when the need arises. "Ian has maintained a vendor-agnostic methodology beautifully in this material. The metrics and graphs, along with background information provided in his case studies, eloquently convey to the reader, 'Methodology above all, tools at your discretion...' Ian's expertise shines through throughout the entire reading experience." -- Matt St. Onge, Enterprise Solution Architect, HCL Technologies America / Teradyne},
author = {Molyneaux, Ian},
isbn = {9780596551056},
pages = {159},
publisher = {O'Reilly Media, Inc.},
title = {{The Art of Application Performance Testing}},
year = {2009}
}
@book{wohlin2012experimentation,
archivePrefix = {arXiv},
arxivId = {arXiv:1011.1669v3},
author = {et al. Wohlin, C.},
booktitle = {Springer Science {\&} Business Media},
doi = {10.1017/CBO9781107415324.004},
eprint = {arXiv:1011.1669v3},
file = {:Users/leosilva/Documents/Estudo/Mestrado/Dissertacao/Referencias/Wohlin-Livro-Novo-2012.pdf:pdf},
isbn = {9788578110796},
issn = {1098-6596},
pmid = {25246403},
title = {{Experimentation in software engineering}},
year = {2012}
}
@article{McConathy1993,
author = {McConathy, Deirdre A.},
file = {:Users/leosilva/Documents/Estudo/Mestrado/Dissertacao/Referencias/p2-mcconathy.pdf:pdf},
journal = {ACM SIGBIO Newsletter},
title = {{Evaluation methods in visualization: Combating the emperor's new clothes phenomenon}},
url = {http://portal.acm.org/citation.cfm?id=163425},
year = {1993}
}
@article{Ahmed2016,
author = {Ahmed, Tarek M. and Bezemer, Cor-Paul and Chen, Tse-Hsun and Hassan, Ahmed E. and Shang, Weiyi},
doi = {10.1145/2901739.2901774},
file = {:Users/leosilva/Documents/Estudo/Mestrado/Dissertacao/Referencias/p1-ahmed.pdf:pdf},
isbn = {9781450341868},
journal = {Proceedings of the 13th International Conference on Mining Software Repositories - MSR '16},
pages = {1--12},
title = {{Studying the effectiveness of application performance management (APM) tools for detecting performance regressions for web applications}},
url = {http://dl.acm.org/citation.cfm?doid=2901739.2901774},
year = {2016}
}
@article{Trumper2010,
author = {Tr{\"{u}}mper, Jonas and Bohnet, Johannes},
file = {:Users/leosilva/Documents/Estudo/Mestrado/Dissertacao/Referencias/p133-trumper.pdf:pdf},
isbn = {9781450300285},
keywords = {Dynamic Analysis, Multithreading, Visualization, P,comprehension,dynamic analysis,multithreading,performance optimization,program,visualization},
pages = {133--142},
title = {{Understanding Complex Multithreaded Software Systems by Using Trace Visualization}},
year = {2010}
}
@article{Kula2014,
abstract = {System maintainers face several challenges stemming from a system and its library dependencies evolving separately. Novice maintainers may lack the historical knowledge required to efficiently manage an inherited system. While some libraries are regularly updated, some systems keep a dependency on older versions. On the other hand, maintainers may be unaware that other systems have settled on a different version of a library. In this paper, we visualize how the dependency relation between a system and its dependencies evolves from two perspectives. Our system-centric dependency plots (SDP) visualize the successive library versions a system depends on over time. The radial layout and heat-map metaphor provide visual clues about the change in dependencies along the system's release history. From this perspective, maintainers can navigate to a library-centric dependants diffusion plot (LDP). The LDP is a time-series visualization that shows the diffusion of users across the different versions of a library. We demonstrate on real-world systems how maintainers can benefit from our visualizations through four case scenarios.},
author = {Kula, Raula Gaikovina and {De Roover}, Coen and German, Daniel and Ishio, Takashi and Inoue, Katsuro},
doi = {10.1109/VISSOFT.2014.29},
file = {:Users/leosilva/Documents/Estudo/Mestrado/Dissertacao/Referencias/VISSOFT2014.pdf:pdf},
isbn = {9780769553054},
journal = {Proceedings - 2nd IEEE Working Conference on Software Visualization, VISSOFT 2014},
keywords = {Software Evolution,Software Maintenance,Software Reuse},
pages = {127--136},
title = {{Visualizing the evolution of systems and their library dependencies}},
year = {2014}
}
@article{Shah2008,
abstract = {This paper presents a new visualization technique for supporting the understanding of exception-handling constructs in Java programs. To understand the requirements for such a visualization, we surveyed a group of software developers, and used the results of that survey to guide the creation of the visualizations. The technique presents the exception-handling information using three views: the quantitative view, the flow view, and the contextual view. The quantitative view provides a high-level view that shows the throw-catch interactions in the program, along with relative numbers of these interactions, at the package level, the class level, and the method level. The flow view shows the type-throw-catch interactions, illustrating information such as which exception types reach particular throw statements, which catch statements handle particular throw statements, and which throw statements are not caught in the program. The contextual view shows, for particular type-throw-catch interactions, the packages, classes, and methods that contribute to that exception-handling construct. The paper also presents a case study in which we evaluated a prototype of the visualization system on a small set of developers.},
annote = {NULL},
author = {Shah, Hina and G{\"{o}}rg, Carsten and Harrold, Mary Jean},
doi = {10.1145/1409720.1409724},
file = {:Users/leosilva/Documents/Estudo/Mestrado/Dissertacao/Referencias/GT-CS-12-08.pdf:pdf},
isbn = {9781605581125},
journal = {Proceedings of the 4th ACM symposium on Software visuallization},
keywords = {Eclipse plugin,exception handling,interactive visualization,multiple views,program understanding},
pages = {19},
title = {{Visualization of exception handling constructs to support program understanding}},
url = {http://dl.acm.org/citation.cfm?id=1409720.1409724},
year = {2008}
}
@article{Maletic2002,
author = {Maletic, Jonathan I and Marcus, Andrian and Collard, Michael L},
file = {:Users/leosilva/Documents/Estudo/Mestrado/Dissertacao/Referencias/01019792.pdf:pdf},
isbn = {0769516629},
journal = {Proceedings of the First International Workshop on Visualizing Software for Understanding and Analysis (VISSOFT'02)},
title = {{A Task Oriented View of Software Visualization}},
year = {2002}
}
@article{Khan2012,
abstract = {Software systems are an integral component of our everyday life as we find them in tools and embedded in equipment all around us. In order to ensure smooth, predictable, and accurate operation of these systems, it is crucial to produce and maintain systems that are highly reliable. A well-designed and well-maintained architecture goes a long way in achieving this goal. However, due to the intangible and often complex nature of software architecture, this task can be quite complicated. The field of software architecture visualization aims to ease this task by providing tools and techniques to examine the hierarchy, relationship, evolution, and quality of architecture components. In this paper, we present a discourse on the state of the art of software architecture visualization techniques. Further, we highlight the importance of developing solutions tailored to meet the needs and requirements of the stakeholders involved in the analysis process.},
author = {Khan, Taimur and Barthel, Henning and Ebert, Achim and Liggesmeyer, Peter},
doi = {10.4230/OASIcs.VLUDS.2011.25},
file = {:Users/leosilva/Documents/Estudo/Mestrado/Dissertacao/Referencias/862.pdf:pdf},
isbn = {9783939897460},
issn = {21906807},
journal = {OpenAccess Series in Informatics},
keywords = {Computer software maintenance;Visualization;},
pages = {25--42},
title = {{Visualization and evolution of software architectures}},
url = {http://dx.doi.org/10.4230/OASIcs.VLUDS.2011.25},
volume = {27},
year = {2012}
}
@article{Spence2005,
abstract = {William Playfair's pie chart is more than 200 years old and yet its intellectual origins remain obscure. The inspiration likely derived from the logic diagrams of Llull, Bruno, Leibniz, and Euler, which were familiar to William because of the instruction of his mathematician brother John. The pie chart is broadly popular but---despite its common appeal---most experts have not been seduced, and the academy has advised avoidance; nonetheless, the masses have chosen to ignore this advice. This commentary discusses the origins of the pie chart and the appropriate uses of the form.},
author = {Spence, I.},
doi = {10.3102/10769986030004353},
file = {:Users/leosilva/Documents/Estudo/Mestrado/Dissertacao/Referencias/10769986030004353.pdf:pdf},
isbn = {1076-9986},
issn = {1076-9986},
journal = {Journal of Educational and Behavioral Statistics},
keywords = {bruno,circle chart,euler,leibniz,llull,logic diagrams,pie chart,playfair},
number = {4},
pages = {353--368},
title = {{No Humble Pie: The Origins and Usage of a Statistical Chart}},
volume = {30},
year = {2005}
}
@article{Williams1998,
author = {Williams, Lg and Smith, Cu},
doi = {10.1145/287318.287353},
file = {:Users/leosilva/Downloads/23725d55a75bf95fd73c19462f495de40c3a.pdf:pdf},
isbn = {1581130600},
journal = {Proceedings of the 1st international workshop on Software and Performance},
number = {c},
pages = {164--177},
title = {{Performance evaluation of software architectures}},
url = {http://dl.acm.org/citation.cfm?id=287353},
year = {1998}
}
@article{VanHees2015,
abstract = {Voronoi treemaps can be used to effectively visualize software quality attributes of a given software system. To easily keep track of how the values of such attributes change over time as the software evolves from one version to the next, it is essential that the produced visualizations are stable in the sense that small changes to the values of the attributes lead to small changes in the visualization. Due to the non-deterministic nature of the standard algorithm for computing Voronoi treemaps, stability is not guaranteed. In this paper we introduce stable Voronoi treemaps for additively weighted power Voronoi diagrams. We employ scaled Hilbert curves to place Voronoi sites in the plane, thereby achieving a predictable first good approximation of the final location of the sites, and then retain the order in which sites are placed along that curve for easy comparison with revisions of the same software system. We show that our algorithm not only provides more stability, but also that because of better placement it needs fewer iterations to compute its result.},
author = {{Van Hees}, Rinse and Hage, Jurriaan},
doi = {10.1109/VISSOFT.2015.7332410},
file = {:Users/leosilva/Documents/Estudo/Mestrado/Dissertacao/Referencias/07332410.pdf:pdf},
isbn = {9781467375269},
journal = {2015 IEEE 3rd Working Conference on Software Visualization, VISSOFT 2015 - Proceedings},
keywords = {Data visualization,Layout,Measurement,Software algorithms,Software systems,Visualization},
pages = {6--15},
title = {{Stable Voronoi-based visualizations for software quality monitoring}},
year = {2015}
}
@book{Bass2007,
abstract = {An eagerly-anticipated revision to one of the seminal books in the field of software architecture; clearly defines and explains the topic.},
author = {Bass, Len and Clements, Paul and Kazman, Rick},
booktitle = {Vasa},
doi = {10.1024/0301-1526.32.1.54},
isbn = {0321154959},
issn = {03008495},
pages = {1--426},
pmid = {21301655},
publisher = {Pearson Education India},
title = {{Software Architecture in Practice}},
volume = {2nd},
year = {2012}
}
@article{SENSALIRE2009,
abstract = {Today, software engineering is a full-grown industry, with many processes, methods, and tools in place. As a consequence hereof, the lifecycle of a software product, consisting of phases such as requirements analysis, architecting, design, development, testing, releasing, and maintenance, is very long, complicated, and expensive. Various analyses estimate that over 80{\%} of the entire lifecycle costs of a software product are in maintenance, and that 50{\%} of this cost relates to program comprehension [68, 164]. Software maintenance (SM) refers to the modification of a software product after delivery to correct faults, to improve performance or other attributes, or to adapt the product to a changed environment [52]. Maintenance can be further classified into four main sub categories i.e. , pre- ventivemaintenance, corrective maintenance, adaptive maintenance and perfective maintenance [127]. To reduce a part of the maintenance costs, several things can be done. A non-exhaustive list hereof includes reducing development, testing and architecting costs; using better, more effective programmers; using more cost-effective process management methodologies such as agile or lean development [106]; and reducing the cost of comprehension. From this palette of instruments, we focus in this dissertation is on the cost reduction process via better program comprehension techniques. There are many ways to support program comprehension. To be able to reason about them, we have to understand why comprehension is difficult in the first place. A set of causes are involved here: Software is large, complex, abstract, changes in time, and involves many people in its construction. All these aspects, both taken individually and even more so in their interplay, make comprehension difficult. To support better, more effective ways to understand large, complex, abstract, and changing programs, several types of techniques have been proposed. Examples hereof source code and dynamic behavior analyses, formal methods, quality metrics, reverse engineering techniques, and visualization techniques. In this thesis, we will examine the last type of technique: Software visualization (SoftVis). In brief, software visualization supports program comprehension by making the abstract concrete; reducing the scale of an entire software (sub)system to one or more compact images; and making the dynamics of software, e.g., its behavior and also its changes in time, visible in space. To this end, software visualization maps the many attributes of a software system, such as structure, behavior, and evolution attributes, to visual elements, such as shape, position, spa- tial order, color, size, texture, and animated behavior. As such, software visualization reduces the exploration of a large, abstract, complex and changing software system to the hopefully intuitive task of visual exploration and navigation of an image. Specific program comprehension tasks are assisted by specific visualization techniques, which are in turn implemented by specific visualization tools. A comprehension-related visualization tool is therefore ‘effective'when, at the end of the day, it helps actual users (software engineers) to accomplish their comprehension-related tasks, e.g., perform their maintenance activities, better [69]. A visualization tool is ‘efficient'when it enables its users to perform their maintenance within a desired time frame. Hence, the efficiency and effectiveness of visualization tools that support program comprehen- sion are intimately related to a specific test of tasks. To identify whether a given visualization tool is indeed efficient and/or effective, or to build such a new tool, there is a need to identify the requirements that such tools are to satisfy [64, 79, 117, 120]. Furthermore, we need to be able to easily quantify whether a given tool, or set of tools, does indeed satisfy this identified set of requirements.},
annote = {NULL},
author = {SENSALIRE, M},
file = {:Users/leosilva/Documents/Estudo/Mestrado/Dissertacao/Referencias/sensalire09.pdf:pdf},
pages = {1 -- 139},
title = {{A Framework to Evaluate the Effectiveness of Software Visualization Tools in Maintenance Activities}},
url = {http://www.cs.rug.nl/{~}alext/PAPERS/PhD/sensalire09.pdf},
year = {2009}
}
@article{Holten2006,
author = {Holten, Danny},
file = {:Users/leosilva/Documents/Estudo/Mestrado/Dissertacao/Referencias/10.1.1.220.8113.pdf:pdf},
journal = {IEEE Transactions on Visualization and Computer Graphics},
keywords = {Visualization},
number = {5},
pages = {741--748},
title = {{Hierrchical Edge Bundles: Visualizaiton of Adjacency Relations in Hierarchical Data}},
volume = {12},
year = {2006}
}
@article{SandovalAlcocer2013,
abstract = {Understanding the root of a performance drop or improvement requires analyzing different program executions at a fine grain level. Such an analysis involves dedicated profiling and representation techniques. JProfiler and YourKit, two recognized code profilers fail, on both providing adequate metrics and visual representations, conveying a false sense of the performance variation root. We propose performance evolution blueprint, a visual support to precisely compare multiple software executions. Our blueprint is offered by Rizel, a code profiler to efficiently explore performance of a set of benchmarks against multiple software revisions.},
author = {{Sandoval Alcocer}, Juan Pablo and Bergel, Alexandre and Ducasse, St{\'{e}}phane and Denker, Marcus},
doi = {10.1109/VISSOFT.2013.6650523},
file = {:Users/leosilva/Documents/Estudo/Mestrado/Dissertacao/Referencias/Sand13a-Vissoft-PreformanceBlueprint.pdf:pdf},
isbn = {9781479914579},
journal = {2013 1st IEEE Working Conference on Software Visualization - Proceedings of VISSOFT 2013},
keywords = {profiling,software evolution,software execution,visualization},
title = {{Performance evolution blueprint: Understanding the impact of software evolution on performance}},
year = {2013}
}
@incollection{Kazman2001,
abstract = {Drawing on clearly identified connections between architecture design decisions and resulting software properties, this book describes systematic methods for evaluating software architectures and applies them to real-life cases. It shows you how such evaluation can substantially reduce risk while adding remarkably little expense and time to the development effort (in most cases, no more than a few days). Evaluating Software Architectures introduces the conceptual background for architecture evaluation and provides a step-by-step guide to the process based on numerous evaluations performed in government and industry.},
author = {Clements, Paul and Kazman, Rick and Klein, Mark},
booktitle = {Addison Wesley Longman SEI Series In Software Engineering},
isbn = {020170482X},
pages = {368},
publisher = {Addison-Wesley},
title = {{Evaluating Software Architectures: Methods and Case Studies}},
url = {http://www.amazon.ca/exec/obidos/redirect?tag=citeulike09-20{\&}path=ASIN/020170482X},
year = {2001}
}
@article{Seriai2014,
abstract = {Software visualization as a research field focuses on the visualization of the structure, behavior, and evolution of software. It studies techniques and methods for graphically representing these different aspects of software. Interest in software visualization has grown in recent years, producing rapid advances in the diversity of research and in the scope of proposed techniques, and aiding the application experts who use these techniques to advance their own research. Despite the importance of evaluating software visualization research, there is little work studying validation methods. As a consequence, it is usually difficult producing compelling evidence about the effectiveness of software visualization contributions. The goal of this paper is to study the validation techniques performed in the software visualization literature. We conducted a systematic mapping study of validation methods in software visualization. We consider 752 articles from multiple sources, published between 2000 and 2012, and study the validation techniques of the software visualization articles. The main outcome of this study is the lack in rigor when validating software visualization tool and techniques. Although software visualization has grown in interest in the last decade, it still lacks the necessary maturity to be properly and thoroughly evaluating its claims. Most article evaluations studied in this paper are qualitative case studies, including discussions about the benefits of the proposed visualizations. The results help understand the needs in software visualization validation techniques. They identify the type of evaluations that should be performed to address this deficiency. The specific analysis of SOFTVIS series articles shows that the specialized conference suffers from the same shortage.},
author = {Seriai, Abderrahmane and Benomar, Omar and Cerat, Benjamin and Sahraoui, Houari},
doi = {10.1109/VISSOFT.2014.19},
file = {:Users/leosilva/Documents/Estudo/Mestrado/Dissertacao/Referencias/vsvtsms.pdf:pdf},
isbn = {978-1-4799-6150-4},
journal = {2014 Second IEEE Working Conference on Software Visualization},
keywords = {Abstracts,Data visualization,IEEE Xplore,Libraries,Software,Software visualization,Systematic mapping study,Systematics,Validation techniques,Visualization},
pages = {60--69},
title = {{Validation of Software Visualization Tools: A Systematic Mapping Study}},
year = {2014}
}
@article{Rufiange2014a,
abstract = {Software designs are ever changing to adapt to new environments and requirements. Tracking and understanding changes in modules and relationships in a software project is difficult, but even more so when the software goes through several types of changes. The typical complexity and size of software also makes it harder to grasp software evolution patterns. In this paper, we present an interactive matrix-based visualization technique that, combined with animation, depicts how software designs evolve. For example, it shows which new modules and couplings are added and removed over time. Our generic visualization supports dynamic and weighted digraphs and is applied in the context of software evolution. Analyzing source code changes is important to determine the software's structural organization and identify quality issues over time. To demonstrate our approach, we explore open-source repositories and discuss some of our findings regarding these evolving software designs.},
author = {Rufiange, Sebastien and Melancon, Guy},
doi = {10.1109/VISSOFT.2014.30},
file = {:Users/leosilva/Documents/Estudo/Mestrado/Dissertacao/Referencias/2014-rufiange-animatrix.pdf:pdf},
isbn = {9780769553054},
journal = {Proceedings - 2nd IEEE Working Conference on Software Visualization, VISSOFT 2014},
keywords = {matrix visualization,network visualization,software design,software evolution,software visualization},
pages = {137--146},
title = {{AniMatrix: A matrix-based visualization of software evolution}},
year = {2014}
}
@article{Pimenta2009,
author = {Pimenta, Marcelo and Dal, Carla M and Freitas, Sasso},
file = {:Users/leosilva/Documents/Estudo/Mestrado/Dissertacao/Referencias/001.pdf:pdf},
title = {{Um panorama das ferramentas de visualizacao de software}},
year = {2009}
}
@misc{Appdynamics,
author = {Appdynamics},
booktitle = {2016},
title = {{Appdynamics}},
url = {https://www.appdynamics.com/},
year = {2016}
}
@article{Wulf2010,
author = {Wulf, Christian},
file = {:Users/leosilva/Documents/Estudo/Mestrado/Dissertacao/Referencias/thesis.pdf:pdf},
title = {{Christian-Albrechts-University of Kiel Software Engineering Group Runtime Visualization of Static and Dynamic Architectural Views of a Software System to identify Performance Problems}},
year = {2010}
}
@article{Jansen2005,
abstract = {Software architectures have high costs for change, are complex, and erode during evolution. We believe these problems are partially due to knowledge vaporization. Currently, almost all the knowledge and information about the design decisions the architecture is based on are implicitly embedded in the architecture, but lack a first-class representation. Consequently, knowledge about these design decisions disappears into the architecture, which leads to the aforementioned problems. In this paper, a new perspective on software architecture is presented, which views software architecture as a composition of a set of explicit design decisions. This perspective makes architectural design decisions an explicit part of a software architecture. Consequently, knowledge vaporization is reduced, thereby alleviating some of the fundamental problems of software architecture.},
author = {Jansen, Anton and Bosch, Jan},
doi = {10.1109/WICSA.2005.61},
file = {:Users/leosilva/Documents/Estudo/Mestrado/Dissertacao/Referencias/download.pdf:pdf},
isbn = {0-7695-2548-2},
journal = {IEEE/IFIP Conf. Software Architecture (WICSA)},
keywords = {design decision,software architecture},
pages = {109--120},
title = {{Software Architecture as a Set of Architectural Design Decisions}},
url = {http://ieeexplore.ieee.org/lpdocs/epic03/wrapper.htm?arnumber=1620096},
year = {2005}
}
@article{Rufiange2014,
abstract = {Identifying and tracking evolving software structures at a design level is a challenging task. Although there are ways to visualize this information statically, there is a need for methods that help analyzing the evolution of software design elements. In this paper, we present a new visual approach to identify variability zones in software designs and explore how they evolve over time. To verify the usefulness of our approach, we did a user study in which participants had to browse software histories and find visual patterns. Most participants were able to find interesting observations and found our approach intuitive and useful. We present a number of design aspects that were observed by participants and the authors using our IHVis tool on four open-source projects. ?? 2013 Elsevier Inc. All rights reserved.},
author = {Rufiange, S{\'{e}}bastien and Fuhrman, Christopher P.},
doi = {10.1016/j.jss.2013.10.044},
file = {:Users/leosilva/Documents/Estudo/Mestrado/Dissertacao/Referencias/2014-rufiange-ihvis.pdf:pdf},
issn = {01641212},
journal = {Journal of Systems and Software},
keywords = {Information hiding,Software design,Software evolution,Software visualization},
number = {1},
pages = {231--249},
title = {{Visualizing protected variations in evolving software designs}},
volume = {88},
year = {2014}
}
@article{Bergel,
abstract = {While traditional approaches to code profiling help locate performance bottlenecks, they offer only limited support for removing these bottlenecks. The main reason is the lack of visual and detailed runtime information to identify and eliminate computation redundancy. We provide two profiling blueprints which help identify and remove performance bottlenecks. The structural distribution blueprint graphically represents the CPU consumption share for each method and class of an application. The behavioral distribution blueprint depicts the distribution of CPU consumption along method invocations, and hints at method candidates for caching optimizations. These two blueprints helped us to significantly optimize Mondrian, an open source visualization engine. Our implementation is freely available for the Pharo development environment and has been evaluated in a number of different scenarios. {\textcopyright} 2010 Springer-Verlag.},
author = {Bergel, Alexandre and Robbes, Romain and Binder, Walter},
doi = {10.1007/978-3-642-13953-6_16},
file = {:Users/leosilva/Documents/Estudo/Mestrado/Dissertacao/Referencias/TR{\_}DCC-20100325-001.pdf:pdf},
isbn = {3642139523},
issn = {03029743},
journal = {Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)},
pages = {291--309},
title = {{Visualizing dynamic metrics with profiling blueprints}},
volume = {6141 LNCS},
year = {2010}
}
@article{Langelier2008,
abstract = {Assessing software quality and understanding how events in its evolution have lead to anomalies are two important steps toward reducing costs in software maintenance. Unfortunately, evaluation of large quantities of code over several versions is a task too time-consuming, if not overwhelming, to be applicable in general. To address this problem, we designed a visualization framework as a semi-automatic approach to quickly investigate programs composed of thousands of classes, over dozens of versions. Programs and their associated quality characteristics for each version are graphically represented and displayed independently. Real-time navigation and animation between these representations recreate visual coherences often associated with coherences intrinsic to subsequent software versions. Exploiting such coherences can reduce cognitive gaps between the different views of software, and allows human experts to use their visual capacity and intuition to efficiently investigate and understand various quality aspects of software evolution. To illustrate the interest of our framework, we report our results on two case studies.},
author = {Langelier, Guillaume and Sahraoui, Houari and Poulin, Pierre},
doi = {10.1109/VLHCC.2008.4639052},
file = {:Users/leosilva/Documents/Estudo/Mestrado/Dissertacao/Referencias/04639052.pdf:pdf},
isbn = {9781424425280},
issn = {1943-6092},
journal = {Proceedings - 2008 IEEE Symposium on Visual Languages and Human-Centric Computing, VL/HCC 2008},
pages = {13--20},
title = {{Exploring the evolution of software quality with animated visualization}},
year = {2008}
}
@inproceedings{Schulz2016,
annote = {NULL},
author = {Schulz, Rodrigo and Beck, Fabian and Felipez, Jhonny Wilder Cerezo and Bergel, Alexandre},
booktitle = {2016 IEEE Working Conference on Software Visualization (VISSOFT)},
doi = {10.1109/VISSOFT.2016.21},
file = {:Users/leosilva/Documents/Estudo/Mestrado/Dissertacao/Referencias/07780153.pdf:pdf},
isbn = {978-1-5090-3850-3},
month = {oct},
pages = {21--25},
publisher = {IEEE},
title = {{Visually Exploring Object Mutation}},
url = {http://ieeexplore.ieee.org/document/7780153/},
year = {2016}
}
@incollection{Neuhauser2011,
abstract = {The goal of this book is multidimensional: a) to help reviving Statistics education in many parts in the world where it is in crisis. For the first time authors from many developing countries have an opportunity to write together with the most prominent world authorities. The editor has spent several years searching for the most reputable statisticians all over the world. International contributors are either presidents of the local statistical societies, or head of the Statistics department at the main university, or the most distinguished statisticians in their countries. b) to enable any non-statistician to obtain quick and yet comprehensive and highly understandable view on certain statistical term, method or application c) to enable all the researchers, managers and practicioners to refresh their knowledge in Statistics, especially in certain controversial fields. d) to revive interest in statistics among students, since they will see its usefulness and relevance in almost all branches of Science.},
archivePrefix = {arXiv},
arxivId = {arXiv:1011.1669v3},
author = {Neuh{\"{a}}user, Markus},
booktitle = {International Encyclopedia of Statistical Science},
doi = {10.1007/978-3-642-04898-2_615},
editor = {Lovric, Miodrag},
eprint = {arXiv:1011.1669v3},
isbn = {978-3-642-04897-5},
issn = {1091-6490},
pages = {1656--1658},
pmid = {9783642048975},
publisher = {Springer Berlin Heidelberg},
title = {{Wilcoxon–Mann–Whitney Test}},
url = {http://www.amazon.com/International-Encyclopedia-Statistical-Science-Miodrag/dp/3642048978},
year = {2011}
}
@inproceedings{Deng2011,
abstract = {This paper presents a scalable, statement-level visualization that shows related code in a way that supports human interpretation of clustering and context. The visualization is applicable to many software-engineering tasks through the utilization and visualization of problem-specific meta-data. The visualization models statement-level code relations from a system-dependence-graph model of the program being visualized. Dynamic, run-time information is used to augment the static program model to further enable visual cluster identification and interpretation. In addition, we performed a user study of our visualization on an example program domain. The results of the study show that our new visualization successfully revealed relevant context to the programmer participants.},
annote = {NULL},
author = {Deng, Fang and DiGiuseppe, Nicholas and Jones, James A.},
booktitle = {2011 6th International Workshop on Visualizing Software for Understanding and Analysis (VISSOFT)},
doi = {10.1109/VISSOF.2011.6069453},
file = {:Users/leosilva/Documents/Estudo/Mestrado/Dissertacao/Referencias/27c05bf2682db149709af45b52801b08f312.pdf:pdf},
isbn = {978-1-4577-0822-0},
month = {sep},
pages = {1--8},
publisher = {IEEE},
title = {{Constellation visualization: Augmenting program dependence with dynamic information}},
url = {http://ieeexplore.ieee.org/document/6069453/},
year = {2011}
}
@article{Magnavita2015,
abstract = {Software evolution produces large amounts of data which software engineers need to understand for their daily activities. The use of software visualization constitutes a promising approach to help them comprehend multiple aspects of the evolving software. However, portraying all the data is not an easy task as there are many dimensions to the data (e.g. time, files, properties) to be considered. This paper presents a new software visualization metaphor inspired by concentric waves, which gives information about the software evolution in different levels of detail. This new metaphor is able to portray large amount of data and may also be used to consider different dimensions of the data. It uses the concepts of the formation of concentric waves to map software evolution data generated during the waves formation life cycle. The metaphor is useful for exploring and identifying certain patterns in the software evolution. To evaluate its applicability, we conducted an exploratory study to show how the visualization can quickly answer different questions asked by software engineers when evolving their software.},
author = {Magnavita, Rodrigo and Novais, Renato and Mendon{\c{c}}a, Manoel},
doi = {10.5220/0005373901260136},
file = {:Users/leosilva/Documents/Estudo/Mestrado/Dissertacao/Referencias/ICEIS{\_}2015{\_}154.pdf:pdf},
isbn = {9789897580963},
journal = {ICEIS 2015 - 17th International Conference on Enterprise Information Systems, Proceedings},
keywords = {Software comprehension,Software engineering,Software evolution,Software visualization},
pages = {126--136},
title = {{Using EVOWAVE to analyze software evolution}},
url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-84939532296{\&}partnerID=tZOtx3y1},
volume = {2},
year = {2015}
}
@article{Gallagher2008,
abstract = {In order to characterize and improve software architecture visualization practice, the paper derives and constructs a qualitative framework, with seven key areas and 31 features, for the assessment of software architecture visualization tools. The framework is derived by the application of the Goal Question Metric paradigm to information obtained from a literature survey and addresses a number of stakeholder issues. The evaluation is performed from multiple stakeholder perspectives and in various architectural contexts. Stakeholders can apply the framework to determine if a particular software architecture visualization tool is appropriate to a given task. The framework is applied in the evaluation of a collection of six software architecture visualization tools. The framework may also be used as a design template for a comprehensive software architecture visualization tool.},
author = {Gallagher, Keith and Hatch, Andrew and Munro, Malcolm and Society, Ieee Computer and Hatch, Andrew and Munro, Malcolm},
doi = {10.1109/TSE.2007.70757},
file = {:Users/leosilva/Documents/Estudo/Mestrado/Dissertacao/Referencias/04378398.pdf:pdf},
isbn = {2007060183},
issn = {0098-5589},
journal = {Software Engineering, IEEE Transactions on},
keywords = {goal question metric paradig,software architecture},
number = {2},
pages = {260--270},
title = {{Software Architecture Visualization: An Evaluation Framework and Its Application}},
volume = {34},
year = {2008}
}
@misc{Pinpoint2016,
author = {Pinpoint},
booktitle = {2016},
title = {{Pinpoint}},
url = {https://github.com/naver/pinpoint},
year = {2016}
}
@inproceedings{Denford2002,
author = {Denford, Mark and O'Neill, Tim and Leaney, John},
booktitle = {Engineering of Computer-Based Systems},
doi = {10.1109/ECBS.2002.999832},
pages = {139--146},
publisher = {IEEE},
title = {{Architecture-based visualisation of computer based systems}},
url = {http://ieeexplore.ieee.org/document/999832/},
year = {2002}
}
@misc{Relic2016,
author = {{New Relic}, Inc},
booktitle = {2016},
keywords = {apm,application monitoring,application performance management,application performance monitoring,mobile monitoring,new relic},
title = {{New Relic}},
url = {http://newrelic.com/},
year = {2015}
}
@article{Caserta2011,
abstract = {Software is usually complex and always intangible. In practice, the development and maintenance processes are time-consuming activities mainly because software complexity is difficult to manage. Graphical visualization of software has the potential to result in a better and faster understanding of its design and functionality, saving time and providing valuable information to improve its quality. However, visualizing software is not an easy task because of the huge amount of information comprised in the software. Furthermore, the information content increases significantly once the time dimension to visualize the evolution of the software is taken into account. Human perception of information and cognitive factors must thus be taken into account to improve the understandability of the visualization. In this paper, we survey visualization techniques, both 2D- and 3D-based, representing the static aspects of the software and its evolution. We categorize these techniques according to the issues they focus on, in order to help compare them and identify the most relevant techniques and tools for a given problem.},
author = {Caserta, Pierre and Zendra, Olivier},
doi = {10.1109/TVCG.2010.110},
file = {:Users/leosilva/Documents/Estudo/Mestrado/Dissertacao/Referencias/visualization{\_}static{\_}aspects{\_}2011.pdf:pdf},
isbn = {1077-2626},
issn = {10772626},
journal = {IEEE Transactions on Visualization and Computer Graphics},
keywords = {Visualization of software,human perception,software comprehension,software maintenance},
number = {7},
pages = {913--933},
pmid = {20733234},
title = {{Visualization of the static aspects of software: A survey}},
volume = {17},
year = {2011}
}
@article{Eick1992,
abstract = {The Seesoft software visualization system allows one to analyze up to 50000 lines of code simultaneously by mapping each line of code into a thin row. The color of each row indicates a statistic of interest, e.g., red rows are those most recently changed, and blue are those least recently changed. Seesoft displays data derived from a variety of sources, such as version control systems that track the age, programmer, and purpose of the code (e.g., control ISDN lamps, fix bug in call forwarding); static analyses, (e.g., locations where functions are called); and dynamic analyses (e.g., profiling). By means of direct manipulation and high interaction graphics, the user can manipulate this reduced representation of the code in order to find interesting patterns. Further insight is obtained by using additional windows to display the actual code. Potential applications for Seesoft include discovery, project management, code tuning, and analysis of development methodologies},
author = {Eick, Stephen G. and Steffen, Joseph L. and Sumner, Eric E.},
doi = {10.1109/32.177365},
isbn = {9789004173675},
issn = {00985589},
journal = {IEEE Transactions on Software Engineering},
keywords = {Change management systems,code browsing,interactive graphics,line oriented statistics,scientific visualization},
number = {11},
pages = {957--968},
pmid = {126},
title = {{Seesoft—A Tool for Visualizing Line Oriented Software Statistics}},
volume = {18},
year = {1992}
}
@article{Lanza2005,
abstract = { CodeCrawler is a language independent, interactive, information visualization tool. It is mainly targeted at visualizing object-oriented software, and has been successfully validated in several industrial case studies over the past few years. CC adheres to lightweight principles: it implements and visualizes polymetric views, visualizations of software enriched with information such as software metrics and other source code semantics. CC is built on top of Moose, an extensible language independent reengineering environment that implements the FAMIX metamodel. In its last implementation, CC has become a general-purpose information visualization tool.},
author = {Lanza, M. and Ducasse, S. and Gall, H. and Pinzger, M.},
doi = {10.1109/ICSE.2005.1553647},
file = {:Users/leosilva/Documents/Estudo/Mestrado/Dissertacao/Referencias/lanza-icse05-tooldemo.pdf:pdf},
isbn = {1-59593-963-2},
journal = {Proceedings. 27th International Conference on Software Engineering, 2005. ICSE 2005.},
keywords = {ch,ifi,information visualization,pinzger,unizh},
number = {June 2016},
pages = {2--3},
title = {{CodeCrawler - an information visualization tool for program comprehension}},
url = {http://www.old.inf.usi.ch/faculty/lanza/Downloads/Lanz05a.pdf},
year = {2005}
}
@article{Corbi1989a,
author = {Corbi, Thomas A},
journal = {IBM Systems Journal},
pages = {294----306},
title = {{Program understanding: Challenge for the 1990s}},
volume = {28},
year = {1989}
}
@article{Pablo2016,
author = {Pablo, Juan and Alcocer, Sandoval and Bergel, Alexandre and Valente, Marco Tulio},
file = {:Users/leosilva/Documents/Estudo/Mestrado/Dissertacao/Referencias/p37-sandoval-alcocer.pdf:pdf},
isbn = {9781450340809},
keywords = {performance,performance analysis,performance variation},
pages = {37--48},
title = {{Learning from Source Code History to Identify Performance Failures Project under Study}},
year = {2016}
}
@article{Svahnberg2002,
abstract = {To sustain the qualities of a software system during evolution, and to adapt the quality attributes as the requirements evolve, it is necessary to have a clear software architecture that is understood by all developers and to which all changes to the system adheres. This software architecture can be created beforehand, but must also be updated as the domain of the software, and hence the requirements on the software system evolves. Creating an architectural structure for a system or part of a system so that the architecture fulfils the desired quality requirements is often hard. In this paper we propose a decision support method to aid in the understanding of different architecture structure candidates for a software system. We propose a method that is adaptable with respect to both the set of potential architecture structures, and quality attributes relevant for the system's domain to help in this task. The method creates a support framework, using a multi-criteria decision method, supporting comparison of different software architecture structures for a specific software quality attribute and vice versa. Moreover, given a prioritization of quality attributes for the software system, or part thereof, the most suitable software architecture structure can be indicated using the created framework.},
author = {Svahnberg, Mikael and Wohlin, Claes and Lundberg, Lars and Mattsson, Michael},
doi = {10.1145/568898.568900},
file = {:Users/leosilva/Documents/Estudo/Mestrado/Dissertacao/Referencias/p819-svahnberg.pdf:pdf},
isbn = {1581135564},
journal = {SEKE 2002 - 14th international conference on Software engineering and knowledge engineering},
keywords = {analytic hierarchy,analytic hierarchy process,architecture structures,quality attributes},
pages = {819--826},
title = {{A Method for Understanding Quality Attributes in Software Architecture Structures}},
url = {http://portal.acm.org/citation.cfm?doid=568760.568900},
year = {2002}
}
@article{Mendes2015,
abstract = {Software development and maintenance activities can be negatively impacted by the presence of technical debt. One of its consequences is the software quality decrease. In order to produce better software, the evolution of technical debt needs to be monitored. However, this is not a trivial task since it usually requires the analysis of large amount of data and different types of debt. The areas of metrics and software visualization can be used to facilitate the monitoring of technical debt. This paper presents an open source tool called VisMinerTD that uses software metrics and visualization to support developers in software comprehension activities including the identification and monitoring of technical debt. VisMinerTD brings a new perspective to the hard work of identifying and monitoring technical debt evolution on software projects. Moreover, the user can easily plug new metrics and new visual metaphors to address specific technical debt identification and monitoring activities.},
author = {Mendes, Thiago S. and Almeida, Daniel A. and Alves, Nicolli S R and Sp{\'{i}}nola, Rodrigo O. and Novais, Renato and Mendon{\c{c}}a, Manoel},
doi = {10.5220/0005464804570462},
file = {:Users/leosilva/Documents/Estudo/Mestrado/Dissertacao/Referencias/ICEIS{\_}2015{\_}305.pdf:pdf},
isbn = {9789897580963},
journal = {ICEIS 2015 - 17th International Conference on Enterprise Information Systems, Proceedings},
keywords = {Metrics,Software maintenance,Software visualization,Technical debt,VisMinerTD},
pages = {457--462},
title = {{VisMinerTD: An open source tool to support the monitoring of the technical debt evolution using software visualization}},
url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-84939528578{\&}partnerID=tZOtx3y1},
volume = {2},
year = {2015}
}
@article{Babar2004,
abstract = {Software engineering community has proposed several methods to evaluate software architectures with respect to desired quality attributes such as maintainability, performance, and so on. There is, however, little effort on systematically comparing such methods to discover similarities and differences between existing approaches. In this paper, we compare four well known scenario-based SA evaluation methods using an evaluation framework. The framework considers each method from the point of view of method context, stakeholders, structure, and reliability. The comparison reveals that most of the studied methods are structurally similar but there are a number of differences among their activities and techniques. Therefore, some methods overlap, which guides us to identify five common activities that can form a generic process model.},
author = {Babar, M.a. and Gorton, Ian},
doi = {10.1109/APSEC.2004.38},
file = {:Users/leosilva/Documents/Estudo/Mestrado/Dissertacao/Referencias/2004{\_}Al Babar {\&} Gorton.pdf:pdf},
isbn = {0-7695-2245-9},
issn = {1530-1362},
journal = {Proceedings of the 11th Asia-Pacific Software Engineering Conference},
pages = {600--607},
title = {{Comparison of scenario-based software architecture evaluation methods}},
url = {http://ieeexplore.ieee.org/xpls/abs{\_}all.jsp?arnumber=1371976},
year = {2004}
}
@article{Barlow2001,
author = {Barlow, Todd and Neville, Padraic},
doi = {1522-4048/01},
file = {:Users/leosilva/Documents/Estudo/Mestrado/Dissertacao/Referencias/barlow2001.pdf:pdf},
journal = {Proceedings of the IEEE Symposium on Information Visualization 2001 (INFOVIS'01)},
title = {{A Comparison of 2-D Visualizations of Hierarchies}},
volume = {2001},
year = {2001}
}
@techreport{komlodi2004information,
author = {Komlodi, A and Sears, A and Stanziola, E},
institution = {ISRC Tech. Report, Dept. of Information Systems, UMBC},
isbn = {ISRC Tech. Report UMBC-ISRC-2004-1},
title = {{Information Visualization Evaluation Review}},
year = {2004}
}
@article{Gracanin2005,
abstract = {The field of software visualization (SV) investigates approaches and techniques for static and dynamic graphical representations of algorithms, programs (code), and processed data. SV is concerned primarily with the analysis of programs and their development. The goal is to improve our understanding of inherintly invisible and intangible software, particularly when dealing with large information spaces that characterize domains like software maintenance, reverse engineering, and collaborative development. The main challenge is to find effective mappings from different software aspects to graphical representations using visual metaphors. This paper proveides an overview of SV research, descibes current research directions, and includes an extensive list of recommended readings.},
author = {Gra{\v{c}}anin, Denis and Matkovi{\'{c}}, Kre{\v{s}}imir and Eltoweissy, Mohamed},
doi = {10.1007/s11334-005-0019-8},
file = {:Users/leosilva/Documents/Estudo/Mestrado/Dissertacao/Referencias/87e1d3a57af8763d6e35f2c3f308f385795e.pdf:pdf},
isbn = {4312050130900},
issn = {16145046},
journal = {Innovations in Systems and Software Engineering},
number = {2},
pages = {221--230},
title = {{Software visualization}},
volume = {1},
year = {2005}
}