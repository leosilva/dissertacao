% Introdução
\chapter{Introdução} \label{ch:introducao}

Quando um avião decola do solo a partir de uma cidade de origem para uma cidade de destino, vários softwares presentes na aeronave auxiliam a tripulação durante o trajeto. Um deles é o \abrv[TCAS -- \textit{Traffic Collision Avoidance System}]{TCAS}II (\textit{Traffic Collision Avoidance System}), um sistema anticolisão que, através de dados obtidos das aeronaves presentes nas imediações, calcula o nível de ameaça de cada uma delas. O software, inclusive, pode realizar manobras alternativas se o risco de colisão for iminente \cite{Williamson1989}.

Existem também softwares para automóveis. Destes, pode ser citado o \abrv[ABS -- \textit{Anti-Lock Break System}]{ABS}(\textit{Anti-Lock Break System}), que calcula a maior força de frenagem possível a ser aplicada nas rodas, no entanto, sem deixa-las travar. O ABS melhora a eficiência dos freios, reduzindo a distância de parada do automóvel e evitando que a dirigibilidade seja perdida durante a frenagem \cite{burckhardt1989anti}.

Além de estar presente em aeronaves e automóveis, os softwares também podem ser encontrados em televisores, celulares, tablets, computadores, \textit{smart} TVs e em outros dispositivos. Ademais, os softwares estão presentes nas mais diversas áreas, como medicina, educação física e direito. Tais exemplos reforçam e justificam a importância que as aplicações têm, estando atualmente presentes no dia a dia da população, nas mais variadas atividades.

Os sistemas podem ser desde os mais simples, como aplicativos de calculadora para smartphones, até mais complexos, como sistemas de tempo real que monitoram pacientes em uma Unidade de Terapia Intensiva \abrv[UTI -- Unidade de Terapira Intensiva]{(UTI)}de um hospital. Todos eles, no entanto, possuem uma arquitetura que serve como base para o seu desenvolvimento.

Como parte integrante da descrição de uma arquitetura, os softwares podem possuir requisitos de qualidade críticos. O TCAS II, por exemplo, requer que o cálculo das ameaças seja realizado com o maior \textit{desempenho} possível. Por sua vez, o ABS necessita que o cálculo da força de frenagem aplicada nas rodas tenha um alto grau de \textit{confiabilidade}, ou seja, quanto mais os freios funcionarem em relação ao número de tentativas, mais confiável ele será. Além de desempenho e confiabilidade, outros exemplos de requisitos de qualidade comuns são segurança, portabilidade, robustez e escalabilidade.

As áreas de arquitetura dos softwares e de requisitos de qualidade são bem abordadas pela disciplina de Engenharia de Software. Não obstante, apesar dessa adequada abordagem, há um entendimento ainda deficiente devido a intrínseca característica que difere os programas de computador da maioria dos produtos industriais: um software é um artefato inerentemente intelectual. É invisível, imaterial \cite{Steinbruckner2010}. Como menciona Ball e Eick \cite{Ball1996}, software é intangível, não tem forma física ou tamanho. Depois que é escrito, o código “desaparece” em arquivos armazenados em discos.

Presentes nos mais variados domínios, os softwares vêm sendo utilizados por usuários com diferentes características e executando em dispositivos distintos, fazendo com que seja alta a demanda por novas funcionalidades e tecnologias ou para reparação de erros. Caserta e Zendra \cite{Caserta2011} mencionam que um software se torna rapidamente complexo quando o seu tamanho aumenta, trazendo dificuldades para o seu entendimento, manutenção e evolução. Nesse sentido, a manutenção e evolução de sistemas de software tem se tornado uma tarefa difícil e crítica com o passar dos anos.

O processo de manutenção é conhecido como o mais caro e o que mais consome tempo dentro do ciclo de vida de um software \cite{Abreu1995}. A maior parte do tempo gasto nesse processo é dedicada a compreender o sistema, especialmente se os desenvolvedores não estiverem envolvidos desde o início do desenvolvimento.

Nesse contexto, a Visualização de Software é uma área da Engenharia de Software que objetiva usar representações visuais para melhorar o entendimento e compreensão de diferentes aspectos de um sistema de software. Alguns desses aspectos incluem padrões de projeto, arquitetura, processo de desenvolvimento, histórico de código-fonte, esquemas de banco de dados, interações de rede, processamento paralelo, execução de processos, dentre outros \cite{Ghanam2008}.

Este capítulo introduz este trabalho. A seção \ref{sec:apresentacao-do-problema} exibe o contexto do trabalho e apresenta o problema a ser tratado. A seção \ref{sec:limitacao-abordagens-atuais} apresenta as principais limitações das abordagens atuais. A seção \ref{sec:abordagem-proposta} apresenta a abordagem proposta, ao passo que a seção \ref{sec:objetivos-gerais-especificos} discute os objetivos gerais e específicos. Por fim, a organização do trabalho é mostrada na seção \ref{sec:organizacao-trabalho}.

\section{Apresentação do Problema} \label{sec:apresentacao-do-problema}

Com o intuito de tornar o software mais compreensível, a área de Visualização de Software lança mão de representações visuais para essa finalidade. Essas representações se fazem necessárias para os analistas, arquitetos e desenvolvedores examinarem os softwares devido a sua natureza complexa, abstrata e difícil de ser observada \cite{Petre2006}. Essa área pode focar em vários aspectos de sistemas de software, como mencionado anteriormente, entretanto, um dos componentes essenciais é a visualização da arquitetura de um software.

Ghanam e Carpendale \cite{Ghanam2008} afirmam que não apenas os arquitetos estão interessados em visualizar arquiteturas de software, mas também os desenvolvedores, testadores, gerentes de projetos e até mesmo os clientes. Um dos principais desafios dessas visualizações é descobrir representações visuais eficientes e eficazes para exibir a arquitetura de um software juntamente com as métricas de código envolvidas.

No entanto, a visualização da arquitetura de um software se torna especialmente difícil quando é adicionada a variável tempo, passando a ser necessária a representação de sua evolução. Desse modo, a quantidade de dados envolvidos aumenta uma vez que todas as versões do software passam a ser consideradas \cite{Caserta2011}\cite{Khan2012}.

Durante o processo de manutenção, mudanças no código-fonte podem causar comportamentos inesperados em tempo de execução, como, por exemplo, o desempenho de partes da aplicação podem ser degradados em uma nova versão em comparação com a versão anterior \cite{SandovalAlcocer2013}. Nesse contexto, a inexistência de atividades para que os desenvolvedores possam entender a evolução arquitetural pode levar a sua degradação \cite{DAmbros2009}, fazendo com que os atributos de qualidade inicialmente definidos, a partir de decisões arquiteturais e de \textit{design} tomadas durante o processo de desenvolvimento, deixem de ser atendidos.

%Diante disso, é importante que alguma abordagem de visualização da evolução arquitetural de um software, em especial quando se trata de um importante atributo de qualidade como o desempenho, auxilie os arquitetos, desenvolvedores e analistas no processo de desenvolvimento, diminuindo a probabilidade de ocorrer a degradação da arquitetura durante o processo de manutenção.

%Diante disso, é importante que alguma abordagem visual para analisar a evolução do atributo de qualidade de desempenho auxilie os desenvolvedores e arquitetos no processo de desenvolvimento, de modo a diminuir a probabilidade de ocorrer a degradação desse atributo de qualidade durante o processo de manutenção.

Diante disso, é importante a definição de uma abordagem visual para facilitar a análise da evolução do atributo de qualidade de desempenho para os desenvolvedores e arquitetos, de modo a diminuir a probabilidade de ocorrer a degradação desse atributo de qualidade durante o processo de manutenção.

\section{Limitações das Abordagens Atuais} \label{sec:limitacao-abordagens-atuais}

De acordo com a literatura, existem várias ferramentas que tratam da visualização da evolução arquitetural de softwares, inclusive com monitoramento de desempenho, cada uma com suas particularidades. Caserta e Zendra \cite{Caserta2011} apontam que essas ferramentas apresentam a evolução arquitetural a partir de: (i) como a arquitetura global é alterada a cada versão, incluindo mudanças no código fonte; (ii) como os relacionamentos entre os componentes evoluem; e (iii) como as métricas evoluem a cada \textit{release}. Este trabalho está relacionado com o último item dessa relação, especificamente com o atributo de qualidade de desempenho, em termos de tempo de execução.

As ferramentas de \textit{profiling} realizam análise desse atributo de qualidade no software, porém com características diferentes. A \textit{VisualVM} \cite{Vis}, distribuída gratuitamente com o \textit{Java Development Kit} \abrv[JDK -- \textit{Java Development Kit}]{(JDK),}exibe o tempo de execução de cada método em tempo real e o usuário pode, à medida que deseja, tirar fotografias instantâneas da execução do software, os chamados \textit{snapshots}. Essa ferramenta, no entanto, não oferece a comparação entre eles ou de versões anteriores do software, tornando difícil a visualização da evolução do atributo de qualidade desempenho, uma vez que teria que ser feita manualmente para cada método desejado.

Já o \textit{JProfiler} \cite{JProfiler}, ferramenta paga, pode exibir o \textit{call graph} de chamadas dos métodos em tempo real, com seus respectivos tempos de execução. Assim como o \textit{VisualVM}, a ferramenta oferece a possibilidade de guardar snapshots de determinados momentos da execução. Contudo, os \textit{snapshots} não são automáticos, o usuário precisa, deliberadamente, informar à ferramenta quando ele deve ser acionado. Uma maneira de contornar esse problema é fazendo o uso de \textit{triggers}, onde o usuário pode configurar a ferramenta para responder a determinados eventos da \textit{Java Virtual Machine} \abrv[JVM -- \textit{Java Virtual Machine}]{(JVM)} e, assim, executar algumas ações. Apesar da funcionalidade ser interessante e poderosa, dependendo do que o usuário deseja, a configuração das \textit{triggers} pode se tornar maçante. A ferramenta oferece a comparação entre os \textit{snapshots}, porém, não é automática e necessita da ação do usuário para escolher quais \textit{snapshots} serão comparados. A ferramenta \textit{YoutKit Java Profiler} \cite{Profiler2016} possui funcionalidades semelhantes às comentadas para o \textit{JProfiler}. Entretanto, é uma ferramenta paga e a comparação entre os \textit{snapshots} também não é automática.

Com exceção do \textit{VisualVM}, as ferramentas de \textit{profiling} mencionadas possuem uma característica em comum: a forma com que apresentam a evolução do atributo de qualidade de desempenho não é automática e tampouco é direcionada ao(s) método(s) desejado(s) pelo usuário. É necessário selecionar manualmente os \textit{snapshots} que se deseja comparar e as ferramentas exibem duas formas de visualização da evolução do desempenho, em geral: \textit{call tree} e \textit{hot spot}. Em ambas, são apresentados todos os métodos monitorados, cabendo ao usuário procurar o método desejado para, então, verificar qual a sua evolução.

Corroborando com o exposto para o \textit{JProfiler} e o \textit{YourKit Java Profiler}, \citeauthor{SandovalAlcocer2013} menciona que essas duas ferramentas, apesar de serem úteis para acompanhar o desempenho geral, saber a diferença dos tempos dos métodos é muitas vezes insuficiente para compreender as razões para a variação de desempenho. Os autores listam algumas limitações dessas duas ferramentas, tais como: as variações de desempenho têm que ser manualmente rastreadas e as visualizações utilizadas são ineficientes. Essas ferramentas também não oferecem maiores detalhes sobre os desvios, tais como: código-fonte dos métodos, possíveis commits que introduziram o desvio e quais tarefas estariam relacionadas com a degradação ou melhoria encontrada. Novamente, caso o usuário queira identificar tais características para determinado método com desvio terá que pesquisar manualmente diretamente na fonte dos dados: repositório de código-fonte e sistema de gerenciamento de tarefas.

\citeauthor{Ahmed2016} realizaram um estudo para verificar se as ferramentas de gerenciamento de desempenho de aplicações\abrv[APM -- \textit{Application Performance Management}]{}(APM, do inglês \textit{Application Performance Management}) são eficazes na identificação de regressões de desempenho. Os autores definem regressão de desempenho quando as atualizações em um software provocam uma degradação no seu desempenho \cite{Ahmed2016}. As ferramentas utilizadas no estudo foram \textit{New Relic} \cite{Relic2016}, \textit{AppDynamics} \cite{Appdynamics}, \textit{Dynatrace} \cite{Dynatrace2016} e \textit{Pinpoint} \cite{Pinpoint2016}. Como resultado, eles mostram que a maioria das regressões inseridas no código-fonte foram detectadas pelas ferramentas. Contudo, o processo de identificação da causa da regressão, ou seja, o método exato cujo código foi inserido, foi mais complicado, sendo necessário bastante trabalho manual: os autores inspecionavam as transações (requisições) marcadas como lentas e, manualmente, comparavam os respectivos \textit{stacktraces} para verificar se a ferramenta indicava corretamente a regressão de desempenho. O processo, mais uma vez, não é automático e não existem visualizações adequadas que esclareçam a regressão de desempenho.

As abordagens existentes trazem melhorias no tocante à necessidade de novas visualizações da evolução da arquitetura, com foco no atributo de qualidade de desempenho, bem como a automação completa (ou parcial) do processo de análise, uma vez que ainda é necessária considerável intervenção manual do usuário nas ferramentas existentes para visualizar a evolução de diferentes versões do sistema. Além da necessidade de novas visualizações, outros requisitos de uma abordagem para análise de desvios de desempenho na evolução de sistemas são mencionados por Pinto \cite{Pinto2015}:
\begin{itemize}
	\item Deveria automatizar o processo ao máximo. Técnicas manuais consomem tempo e são custosas, além de não se mostrarem adequadas se o processo de avaliação requerer a análise de sucessivas evoluções;
	\item Os softwares podem ser muitos grandes para uma análise completa. Dessa forma, a ferramenta deveria focar em partes selecionadas do sistema;
	\item A ferramenta deveria ser capaz de medir o desempenho de determinados cenários e seus métodos a fim de identificar onde ocorreu o desvio;
	\item Deveria prover suporte para análise do código-fonte com o intuito de oferecer \textit{feedback} detalhado sobre o código relacionado com o desvio detectado;
	\item Deveria ser capaz de acessar dados dos repositórios do software, como ferramentas de controle de versão e sistemas de gerenciamento de tarefas, com a finalidade de exibir as mudanças relacionadas ao código com desvio de desempenho.
\end{itemize}

A análise arquitetural dos atributos de qualidade pode ser feita baseada em cenários, conforme mencionados acima, no terceiro ponto. Nesse contexto, um cenário é definido como uma ação de alto nível que representa a maneira como os \textit{stakeholders} interagem com o sistema.

\section{Abordagem Proposta} \label{sec:abordagem-proposta}

Este trabalho apresenta uma ferramenta, chamada \textit{\toolName}, cujo objetivo é aplicar técnicas de visualização de software para ajudar desenvolvedores e arquitetos a analisar a evolução do atributo de qualidade de desempenho, em termos de tempo de execução, ao longo das versões de um software. A ferramenta propõe duas visualizações com escopos e granularidades diferentes e proporciona ao usuário mecanismos de interação para explorá-las.

O tempo de execução, neste trabalho, é o tempo que o método/cenário demora para executar. Pode também ser tratado como tempo de resposta. Para medir o desempenho, além do tempo de execução, outras propriedades podem ser usadas, como: consumo de memória, entrada e saída de disco, uso do processador e tráfego de rede \cite{Malik2013}. A medição desse atributo em termos de tempo de execução foi escolhida por se tratar de uma propriedade geral e comum para a capacidade de resposta de um sistema.

%Este trabalho visa aplicar técnicas de visualização de software para acompanhar a evolução arquitetural do atributo de qualidade de desempenho. Pretende-se que as visualizações sejam capazes de exibir os cenários e métodos relacionados que tiveram desvios de desempenho durante a avaliação de diferentes versões do sistema, de forma direta e fácil.

A ferramenta foi implementada como extensão a outra já existente, chamada \textit{\perfMinerName} \cite{Pinto2015}. Essa ferramenta busca apontar quais cenários degradaram ou otimizaram o atributo de qualidade de desempenho. A escolha desse atributo de qualidade se deu pelo fato de ser uma propriedade crítica para a maioria dos sistemas de software atuais.

A extensão proposta visa oferecer um melhor entendimento da evolução desse atributo de qualidade na arquitetura de um software por parte dos arquitetos e desenvolvedores, beneficiando-os ao: (i) fornecer uma visão geral dos cenários com desvios de desempenho entre uma determinada versão do software e a anterior; (ii) possibilitar a identificação do cenário que possuiu o maior tempo de execução; (iii) saber qual desses cenários teve o maior desvio de desempenho; (iv) acompanhar a evolução de cada cenário ao longo das versões analisadas; (v) saber, para cada cenário, os métodos que foram detectados com algum tipo de desvio, além de ter conhecimento sobre os métodos que foram adicionados e removidos; e (vi) fornecer uma listagem de \textit{commits} que possivelmente foram as causas dos desvios de desempenho identificados. Com base nisso, a equipe de desenvolvimento pode tomar ações para sanar possíveis problemas no desempenho das aplicações.

% perceber quais cenários de casos de uso degradaram ou melhoraram o seu desempenho; (ii) identificar qual trecho de código-fonte foi o responsável por uma dada degradação; e (iii) identificar questões de desenvolvimento associadas, como quando e qual desenvolvedor realizou mudanças relacionadas à degradação, e qual tarefa está relacionada a alteração no sistema de gerenciamento de tarefas.

\section{Objetivos Gerais e Específicos} \label{sec:objetivos-gerais-especificos}

O objetivo principal deste trabalho é implementar uma ferramenta com o intuito de prover um conjunto de visualizações de modo a aprimorar o entendimento da evolução do atributo de qualidade de desempenho. A implementação dessa ferramenta foi feita estendendo outra ferramenta já existente desenvolvida pelo grupo de pesquisa \textit{Automated Software Engineering}, do Centro de Ciências Exatas e da Terra \abrv[CCET -- Centro de Ciências Exatas e da Terra]{(CCET)}da \abrv[UFRN -- Universidade Federal do Rio Grande do Norte]{UFRN.}

A ferramenta estendida, chamada de \textit{\perfMinerName} \cite{Pinto2015}, pode ser definida como uma abordagem automatizada baseada em cenários para identificar desvios de desempenho, em termos de tempo de execução. A ferramenta indica, também, quais trechos de código-fonte podem ter causado a variação de desempenho baseado na mineração de \textit{commits} e questões de desenvolvimento responsáveis por alterá-los. Técnicas de análise dinâmica e mineração de dados são usadas pela ferramenta para atingir os seus objetivos. Estendê-la, adicionando visualizações, irá permitir aos usuários identificar adequadamente os cenários e métodos com desvio de desempenho ocorridos durante a evolução do sistema. As visualizações podem apontar os pontos onde o software degradou e, a partir de então, os usuários podem estabelecer formas de otimizar o desempenho da aplicação. Nesse contexto, os objetivos específicos deste trabalho são:
\begin{itemize}
	\item Pesquisar as principais abordagens de visualização da evolução de arquiteturas de software, em especial do atributo de qualidade de desempenho, a fim de conhecer quais técnicas são utilizadas atualmente, e identificar lacunas que servem como motivação para o desenvolvimento do trabalho;
	\item Projetar e implementar a ferramenta \textit{{\toolName}} como extensão ao \textit{\perfMinerName}. A ferramenta é desenvolvida na linguagem de programação Groovy, de modo que a análise de desempenho é suportada para sistemas desenvolvidos na linguagem Java, além do Groovy;
	\item Realizar estudos qualitativos com desenvolvedores e arquitetos de sistemas reais de diferentes domínios para avaliar a utilidade das visualizações, a facilidade de se encontrar as informações dispostas e a aplicabilidade da ferramenta como parte integrante dos processos de desenvolvimento desses sistemas.
\end{itemize}

\section{Organização do trabalho} \label{sec:organizacao-trabalho}

Este trabalho está organizado como segue: o capítulo \ref{ch:fundamentacao-teorica} reúne os principais conceitos necessários para o entendimento do trabalho, tais como arquitetura de software, visualização de software e ferramentas de análise de desempenho. O capítulo \ref{ch:visualizacoes} apresenta a solução proposta, mostrando as visualizações definidas e implementadas para melhorar o entendimento das análises, além de explicar o funcionamento do \textit{\perfMinerName} integrado com o conjunto de visualizações proposto. O capítulo \ref{ch:avaliacao} explica o estudo empírico a ser conduzido para avaliação do trabalho. O capítulo \ref{ch:trabalhos-relacionados} exibe trabalhos relacionados, mencionando as suas limitações e comparando-os com este trabalho. Finalmente, o capítulo \ref{ch:conclusao} mostra o cronograma planejado para a conclusão do trabalho e discute as limitações percebidas até o momento. {\color{red} VERIFICAR A ESTRUTURA DEPOIS...}